[
  {
    "id": 1,
    "level": "junior",
    "question": "What are the main components of an Android application?",
    "look_for": "Understanding of the four fundamental building blocks and ability to briefly explain what each does.",
    "answer": "The four fundamental Android components are: **1) Activities** - UI screens that users interact with, each representing a single focused task (e.g., displaying a list, showing a form). **2) Services** - Background components that perform long-running operations without UI (e.g., playing music, downloading files, syncing data). **3) Broadcast Receivers** - Components that respond to system-wide announcements like battery low, network connectivity changes, incoming calls, or custom app events. **4) Content Providers** - Manage and share structured app data (databases, files) with other applications through a standardized interface. All components must be declared in AndroidManifest.xml and each has its own specific lifecycle.",
    "short_answer": "Activities, Services, Broadcast Receivers, and Content Providers."
  },
  {
    "id": 2,
    "level": "junior",
    "question": "Explain the Android Activity lifecycle.",
    "look_for": "Knowledge of the basic lifecycle methods and when they're called, especially onCreate, onResume, onPause.",
    "answer": "The **Activity lifecycle** consists of these sequential callback methods: **onCreate()** (called once when activity is created - initialize UI, set content view, bind views), **onStart()** (activity becomes visible but not yet interactive), **onResume()** (activity is now interactive and in foreground - resume animations, acquire resources), **onPause()** (activity losing focus, partially visible - pause animations, save data), **onStop()** (activity no longer visible - release resources), **onDestroy()** (final cleanup before activity is destroyed). The flow can skip steps: onPause() → onResume() without onStop(). Proper lifecycle management is critical for avoiding memory leaks, ANRs, and data loss.",
    "short_answer": "onCreate() → onStart() → onResume() → onPause() → onStop() → onDestroy(). The activity goes through these states as users interact with it."
  },
  {
    "id": 3,
    "level": "junior",
    "question": "What is the difference between LinearLayout and RelativeLayout?",
    "look_for": "Basic understanding of layout managers and when to use each one for simple UI designs.",
    "answer": "**LinearLayout** arranges child views in a single direction - either horizontal (side-by-side with `android:orientation=\"horizontal\"`) or vertical (stacked with `android:orientation=\"vertical\"`). It's simple and predictable but can lead to deeply nested view hierarchies for complex UIs, impacting performance. **RelativeLayout** positions views relative to each other or the parent container using attributes like `layout_toLeftOf`, `layout_below`, `layout_alignParentTop`, `layout_centerInParent`. More flexible for complex positioning but has been largely replaced by ConstraintLayout. **Use LinearLayout** for simple lists or rows, **RelativeLayout** for overlapping or relative positioning, but **prefer ConstraintLayout** for modern apps as it offers better performance with flatter hierarchies.",
    "short_answer": "LinearLayout arranges views in a single direction (horizontal or vertical), while RelativeLayout positions views relative to each other or the parent."
  },
  {
    "id": 4,
    "level": "junior",
    "question": "What is an Intent in Android?",
    "look_for": "Understanding of explicit vs implicit intents and ability to give a simple example.",
    "answer": "An **Intent** is a messaging object that facilitates communication between Android components. **Explicit Intents** specify the exact target component by fully-qualified class name: `Intent(this, DetailActivity::class.java)` - used for navigation within your own app where you know the destination. **Implicit Intents** declare a general action and let the system find compatible apps: `Intent(Intent.ACTION_VIEW, Uri.parse(\"https://...\"))` or `Intent(Intent.ACTION_SEND)` - used for opening URLs, sharing content, making phone calls, etc. If multiple apps can handle the intent, Android shows a chooser dialog. Intents can carry data via extras: `intent.putExtra(\"key\", value)` and `intent.getStringExtra(\"key\")`.",
    "short_answer": "An Intent is a messaging object used to request an action from another app component, like starting an activity or service."
  },
  {
    "id": 5,
    "level": "junior",
    "question": "What is the AndroidManifest.xml file?",
    "look_for": "Knowledge that it declares activities, permissions, and app metadata.",
    "answer": "**AndroidManifest.xml** is the essential configuration file located at the app's root that describes critical app information to the Android system: **1) Component declarations** - all activities, services, broadcast receivers, and content providers (components not declared here are invisible to the system). **2) Permissions** - required permissions like INTERNET, CAMERA, ACCESS_FINE_LOCATION. **3) API levels** - minSdkVersion, targetSdkVersion, and maxSdkVersion. **4) Hardware/software features** - camera, GPS, Bluetooth requirements. **5) Intent filters** - which implicit intents components can handle. **6) App metadata** - app name, icon, theme, backup settings. The manifest is parsed during app installation.",
    "short_answer": "A configuration file that describes essential information about the app including components, permissions, and minimum API level."
  },
  {
    "id": 6,
    "level": "junior",
    "question": "What is the difference between View and ViewGroup?",
    "look_for": "Understanding of the UI hierarchy and that ViewGroup extends View.",
    "answer": "**View** is the base class for all UI components in Android - it represents a rectangular area on screen that handles drawing and event handling. Examples include Button, TextView, ImageView, EditText - these are the individual, atomic UI elements users interact with. **ViewGroup** is a special subclass of View that can contain and arrange other Views (children), acting as an invisible container or layout manager. Examples include LinearLayout, FrameLayout, RelativeLayout, ConstraintLayout, ScrollView. ViewGroup extends View, so all containers are Views, but not all Views are containers. Together they form a tree hierarchy: ViewGroup nodes branch out containing other ViewGroups or leaf View nodes. This composition pattern enables building complex UIs from simple components.",
    "short_answer": "View is a basic UI component (like Button, TextView), while ViewGroup is a container that holds other Views (like LinearLayout, ConstraintLayout)."
  },
  {
    "id": 7,
    "level": "junior",
    "question": "How do you handle button clicks in Android?",
    "look_for": "Practical knowledge of event handling and at least one approach to implementing click listeners.",
    "answer": "Modern Android/Kotlin offers multiple approaches to handle button clicks: **1) Lambda expression** (most common): `button.setOnClickListener { /* handle click */ }` - concise, leverages Kotlin's SAM conversion. **2) Anonymous inner class**: `button.setOnClickListener(object : View.OnClickListener { override fun onClick(v: View?) { /* handle */ } })` - verbose but explicit. **3) Method reference**: `button.setOnClickListener(::handleClick)` where `handleClick` is a function. **4) XML onClick attribute**: `android:onClick=\"methodName\"` in XML (discouraged - breaks encapsulation, hard to refactor). **5) Jetpack Compose**: use `onClick` parameter directly: `Button(onClick = { /* handle */ }) { Text(\"Click\") }`. Lambda approach is standard in modern Kotlin development.",
    "short_answer": "Implement OnClickListener interface or use lambda expressions with setOnClickListener() method."
  },
  {
    "id": 8,
    "level": "junior",
    "question": "What is R.java file in Android?",
    "look_for": "Understanding that it's auto-generated and shouldn't be modified manually.",
    "answer": "**R.java** (or R.kt in Kotlin) is an automatically generated class that contains unique integer IDs for every resource in your project's `res/` directory. It's organized by resource type with nested classes: `R.drawable` (images), `R.layout` (XML layouts), `R.string` (strings), `R.id` (view IDs), `R.color`, `R.dimen`, etc. For example, `R.layout.activity_main` references the `activity_main.xml` file, and `R.id.button` references a view with `android:id=\"@+id/button\"`. **Critical rules**: Never manually edit this file - it regenerates automatically on every build. If it's missing or showing errors, clean and rebuild the project. Modern Android development with View Binding or Data Binding reduces direct R class usage, but it remains fundamental to resource management.",
    "short_answer": "An auto-generated file that contains resource IDs for all resources in the res/ folder."
  },
  {
    "id": 9,
    "level": "junior",
    "question": "What is the difference between dp and px?",
    "look_for": "Understanding of screen density and why dp is preferred for responsive design.",
    "answer": "**dp (density-independent pixels)** is a virtual pixel unit that automatically scales based on screen density, ensuring consistent physical sizes across devices. 1dp equals approximately 1 pixel on a 160dpi (mdpi baseline) screen, and scales proportionally: 1.5px on hdpi (240dpi), 2px on xhdpi (320dpi), 3px on xxhdpi (480dpi), 4px on xxxhdpi (640dpi). **Always use dp for layout dimensions** (widths, heights, margins, padding) to maintain consistent sizes regardless of screen density. **px (pixels)** maps directly to actual screen pixels without scaling - avoid for layouts as a 100px view appears much smaller on high-density screens. **sp (scale-independent pixels)** is like dp but also respects the user's font size accessibility settings - **always use sp for text sizes** to support users with visual impairments. Example: a 48dp button appears approximately 9mm physically on all devices.",
    "short_answer": "dp (density-independent pixels) scales with screen density, while px (pixels) is absolute. Use dp for layouts to support different screen sizes."
  },
  {
    "id": 10,
    "level": "junior",
    "question": "What is a Toast in Android?",
    "look_for": "Knowledge of when to use Toast vs Snackbar, understanding of duration settings.",
    "answer": "A **Toast** is a simple, lightweight feedback mechanism that displays a brief message in a small popup that automatically disappears after a timeout. Created via `Toast.makeText(context, \"Message\", Toast.LENGTH_SHORT).show()` where LENGTH_SHORT displays for ~2 seconds and LENGTH_LONG for ~3.5 seconds. Toasts appear as an overlay above all other apps, cannot be dismissed manually, and don't accept user interaction. They're appropriate for very brief, non-critical feedback like \"File saved\" or \"No internet connection\". **Modern best practice**: prefer **Snackbar** over Toast because Snackbar is dismissible, can include action buttons, respects accessibility better, and stays within your app's boundaries. Use Toast only for extremely brief, informational messages that don't require user action or acknowledgment.",
    "short_answer": "A Toast is a small popup message that appears briefly to provide feedback to the user."
  },
  {
    "id": 11,
    "level": "junior",
    "question": "What is the difference between match_parent and wrap_content?",
    "look_for": "Basic understanding of layout parameters and how they affect view sizing.",
    "answer": "**match_parent** (formerly called fill_parent) makes a view expand to fill its parent container's available space in that dimension, respecting the parent's padding. **wrap_content** sizes the view to be only as large as necessary to contain its content - for TextView it adapts to text length, for ImageView to image dimensions. Example: A Button with `layout_width=\"wrap_content\"` adjusts its width to fit the button text plus padding; `layout_width=\"match_parent\"` makes it span the full width of its container. A third option is setting explicit dimensions like `layout_width=\"100dp\"`. These are **LayoutParams** values that work with the parent's layout manager (LinearLayout, Constraint Layout, etc.) to determine the final measured size during the layout pass. Understanding these is fundamental to creating responsive Android UIs.",
    "short_answer": "match_parent makes a view as large as its parent, while wrap_content sizes the view to fit its content."
  },
  {
    "id": 12,
    "level": "junior",
    "question": "What is an Adapter in Android?",
    "look_for": "Understanding of the adapter pattern and familiarity with common adapters like ArrayAdapter.",
    "answer": "An **Adapter** acts as a bridge between a data source (ArrayList, database cursor, array) and UI components that display collections (ListView, GridView, Spinner, RecyclerView). It converts each data item into a View to display in the collection. The adapter pattern enables efficient view recycling - as list items scroll off-screen, their views are reused for new data rather than creating new views constantly. **Common adapter types**: **ArrayAdapter** (simple lists from arrays/ArrayLists), **CursorAdapter** (database query results), **RecyclerView.Adapter** (modern, most efficient, requires ViewHolder pattern). Key methods: `getCount()` returns item count, `getItem(position)` returns data at position, `getView()`/`onBindViewHolder()` creates/updates views. Adapters are critical for displaying large datasets efficiently without excessive memory usage.",
    "short_answer": "An Adapter acts as a bridge between data and UI components like ListView or RecyclerView, converting data into views."
  },
  {
    "id": 13,
    "level": "junior",
    "question": "What is ADB?",
    "look_for": "Knowledge of basic ADB commands like install, logcat, shell.",
    "answer": "**Android Debug Bridge (ADB)** is a versatile command-line tool included in the Android SDK platform-tools that enables communication between development machines and Android devices (physical or emulators) via USB or wireless connection. **Essential commands**: `adb devices` (list connected devices), `adb install app.apk` (install app), `adb uninstall com.package.name`, `adb logcat` (view system logs), `adb shell` (access device Unix shell), `adb push` / `adb pull` (transfer files to/from device), `adb forward` (port forwarding), `adb bugreport` (generate bug reports). ADB enables app installation/debugging, log viewing, file management, screenshots (`adb exec-out screencap`), device control, and much more without touching the device. It's fundamental for Android development workflow and automation.",
    "short_answer": "Android Debug Bridge (ADB) is a command-line tool for communicating with Android devices for debugging and development."
  },
  {
    "id": 14,
    "level": "junior",
    "question": "What is Gradle in Android?",
    "look_for": "Basic understanding of build.gradle files and dependency management.",
    "answer": "**Gradle** is Android's official build automation system that handles the entire build process: compiling source code (Java/Kotlin), processing resources, managing dependencies from Maven/Google repositories, creating different build variants (debug/release/custom flavors), running unit/instrumentation tests, code shrinking/obfuscation (R8), and packaging into APK or Android App Bundle. **Key configuration files**: **build.gradle (Project level)** - defines repositories and project-wide settings, **build.gradle (Module/App level)** - dependencies (`implementation`, `api`), SDK versions (`minSdk`, `targetSdk`, `compileSdk`), build types (debug, release with signing), product flavors (free/paid variants). Uses Groovy or Kotlin DSL syntax. Features like incremental builds, build caching, and parallel execution optimize build speed. The Gradle Wrapper (`gradlew`) ensures consistent Gradle versions across team members.",
    "short_answer": "Gradle is the build system for Android that compiles code, manages dependencies, and packages the app."
  },
  {
    "id": 15,
    "level": "junior",
    "question": "What is the difference between implicit and explicit intents?",
    "look_for": "Ability to provide examples of each, understanding of intent filters.",
    "answer": "**Explicit Intents** specify the exact target component by its fully-qualified class name, used for navigating within your own app where you know the precise destination: `Intent(this, DetailActivity::class.java)` or `Intent().setComponent(ComponentName(\"com.app\", \"com.app.DetailActivity\"))`. The system directly starts the specified component. **Implicit Intents** declare a general action and optional data/type, letting the Android system find all apps with matching intent filters: `Intent(Intent.ACTION_VIEW, Uri.parse(\"https://google.com\"))` for opening URLs, `Intent(Intent.ACTION_SEND).setType(\"text/plain\")` for sharing text, `Intent(Intent.ACTION_DIAL)` for phone dialer. If multiple apps match, the system presents a chooser dialog. **Key distinction**: Explicit intents are for internal app navigation (you control both sides); Implicit intents are for system integrations and third-party app interactions (unknown target).",
    "short_answer": "Explicit intents specify the exact component to start, while implicit intents declare an action for any app to handle."
  },
  {
    "id": 16,
    "level": "junior",
    "question": "What is a Bundle in Android?",
    "look_for": "Knowledge of common data types that can be stored and how to retrieve them.",
    "answer": "A **Bundle** is a type-safe, key-value container (similar to Map<String, Object>) used extensively in Android for data passing and state preservation. **Primary uses**: **1) Passing data between components** - add extras to intents: `intent.putExtra(\"user_id\", 123).putExtra(\"name\", \"John\")`, retrieve with type-safe methods: `intent.getIntExtra(\"user_id\", -1)`, `intent.getStringExtra(\"name\")`. **2) Saving instance state** - `onSaveInstanceState(Bundle outState)` persists data across configuration changes (rotation) or process death, restored in `onCreate(Bundle savedInstanceState)`. **Supported types**: all primitives, String, CharSequence, Parcelable, Serializable, arrays of these, and nested Bundles. Bundle is optimized for Android's IPC (Inter-Process Communication) and faster than generic serialization. Unlike JSON, it maintains type safety and integrates natively with Android APIs.",
    "short_answer": "A Bundle is a key-value container used to pass data between activities or save instance state."
  },
  {
    "id": 17,
    "level": "junior",
    "question": "What is the purpose of the res folder?",
    "look_for": "Understanding of different resource folders (drawable, layout, values) and resource qualifiers.",
    "answer": "The **res/** directory contains all non-code resources organized by type: **drawable/** (PNG/JPG images, XML drawables, vector graphics), **layout/** (XML UI definitions), **values/** (strings.xml, colors.xml, dimens.xml, styles.xml, themes.xml, arrays.xml), **mipmap/** (launcher icons at multiple densities - mdpi/hdpi/xhdpi/xxhdpi/xxxhdpi), **raw/** (arbitrary files accessed via InputStream), **menu/** (menu XML), **anim/** and **animator/** (animations), **xml/** (arbitrary XML configuration), **font/** (custom fonts). **Resource qualifiers** enable device-specific alternatives: `-v31` (API level), `-land`/`-port` (orientation), `-en`/`-es` (language), `-ldpi`/`-xxhdpi` (density), `-sw600dp` (smallest width), `-night` (dark mode). Example: `layout-land-v31/` for landscape layouts on Android 12+. Android automatically selects the best-matching resource at runtime based on device configuration, enabling responsive, localized apps.",
    "short_answer": "The res folder contains all non-code resources like layouts, images, strings, and colors."
  },
  {
    "id": 18,
    "level": "junior",
    "question": "What is a ContentProvider?",
    "look_for": "Basic understanding of data sharing between apps and content URIs.",
    "answer": "A **ContentProvider** is an Android component that manages access to a structured set of data (databases, files, network) and provides a standardized interface for other apps to securely query, insert, update, or delete that data. It abstracts the underlying data storage mechanism behind a REST-like API accessed via content URIs following the pattern: `content://authority/path/id`. **System examples**: ContactsContract.Contacts (contacts), MediaStore (media files), CalendarContract (calendar events). **To create**: extend ContentProvider class, implement required methods (`query()`, `insert()`, `update()`, `delete()`, `getType()`), declare in manifest with permissions and authorities. Other apps access via ContentResolver: `contentResolver.query(uri, projection, selection, selectionArgs, sortOrder)`. ContentProviders enable secure, permission-controlled data sharing between apps while maintaining encapsulation of storage implementation.",
    "short_answer": "ContentProvider manages shared app data that other apps can query or modify through a consistent interface."
  },
  {
    "id": 19,
    "level": "junior",
    "question": "What is ANR in Android?",
    "look_for": "Understanding that long operations should be moved off the main thread.",
    "answer": "**Application Not Responding (ANR)** is an error condition where Android displays a dialog offering to force-close or wait when the main/UI thread is blocked too long: **5+ seconds** for input events (touches, key presses), **10+ seconds** for BroadcastReceiver.onReceive(), **20+ seconds** for Service.onStartCommand() in foreground. **Common causes**: network operations on main thread (HTTP requests, socket connections), heavy computations (image processing, large data parsing), synchronous database queries, file I/O (reading/writing large files), infinite loops, or deadlocks. **Prevention strategies**: Use Kotlin coroutines with Dispatchers.IO/Default for blocking operations, WorkManager for background tasks, AsyncTask alternatives like Executors/Thread pools. **StrictMode** helps detect violations during development: `StrictMode.setThreadPolicy(ThreadPolicy.Builder().detectNetwork().penaltyLog().build())`. ANRs severely damage user experience and app ratings - always keep the UI thread responsive.",
    "short_answer": "Application Not Responding (ANR) occurs when the UI thread is blocked for too long (5+ seconds)."
  },
  {
    "id": 20,
    "level": "junior",
    "question": "What is the difference between onCreate() and onStart()?",
    "look_for": "Understanding that onCreate happens once, while onStart can be called multiple times.",
    "answer": "**onCreate(Bundle savedInstanceState)** is called exactly once when an activity is first created - this is where you perform one-time initialization: call `setContentView(R.layout.activity_main)` to inflate the UI, initialize member variables, bind views (findViewById or View Binding), set up RecyclerViews/adapters, initialize ViewModels. The Bundle parameter contains saved state if the activity is being recreated after a configuration change or process death (check `savedInstanceState != null`). **onStart()** is called when the activity becomes visible to the user but isn't yet interactive, and can be called multiple times throughout the activity's life (after onStop() when returning). **Key differences**: onCreate() happens once per activity instance (one-time setup), onStart() happens each time the activity becomes visible (recurrent setup like registering broadcast receivers, starting animations). Use onCreate() for permanent initialization, onStart() for operations needed each time the activity becomes visible and reversed in onStop().",
    "short_answer": "onCreate() is called once when the activity is first created. onStart() is called when the activity becomes visible to the user."
  },
  {
    "id": 21,
    "level": "junior",
    "question": "What is Logcat?",
    "look_for": "Familiarity with log levels (Verbose, Debug, Info, Warn, Error) and filtering.",
    "answer": "**Logcat** is Android's unified, system-wide logging system that collects and displays real-time log messages from your app, system services, framework components, and other apps running on the device. **Log levels** (increasing severity): VERBOSE (detailed debug info), DEBUG (general debugging), INFO (informational messages), WARN (warnings/potential issues), ERROR (error conditions), ASSERT (critical failures that should never happen). **Usage in code**: `Log.v/d/i/w/e(TAG, message, throwable)` where TAG is typically the class name: `private const val TAG = \"MainActivity\"`. **Viewing logs**: Android Studio's Logcat window with filtering by package name, tag, log level, or regex patterns; or command line: `adb logcat` with options like `adb logcat -s TAG_NAME` or `adb logcat *:E` (errors only). Includes stack traces for crashes, making it essential for debugging. **Production**: use ProGuard/R8 to remove logging in release builds for security and performance.",
    "short_answer": "Logcat is Android's logging system that displays system messages, including stack traces, log messages from your app, and system services."
  },
  {
    "id": 22,
    "level": "junior",
    "question": "What is a Snackbar?",
    "look_for": "Understanding of when to use Snackbar vs Toast or Dialog.",
    "answer": "**Snackbar** is a Material Design component that displays brief messages at the bottom of the screen with optional action button and swipe-to-dismiss capability, providing lightweight feedback about operations without interrupting user experience. Created via `Snackbar.make(view, \"Message\", Snackbar.LENGTH_SHORT).show()`. **Advanced features**: Action button (`setAction(\"UNDO\") { /* handle */ }`), custom duration (LENGTH_SHORT, LENGTH_LONG, LENGTH_INDEFINITE), anchoring to views like FAB, custom colors/styling, callbacks (`addCallback()`). Integrates with CoordinatorLayout for automatic animations and smart positioning around other views. **Advantages over Toast**: dismissible by swiping, supports user actions, stays within app context (not system-wide overlay), better accessibility support, respects app theme, can show indefinitely until dismissed. **Best practices**: use for actionable feedback, errors that users can retry, undo operations, or confirming successful actions. Snackbar is the modern, Material Design-compliant replacement for Toast.",
    "short_answer": "Snackbar is a lightweight feedback message that appears at the bottom of the screen, can include an action, and dismisses after a timeout or user action."
  },
  {
    "id": 23,
    "level": "junior",
    "question": "What is the difference between String and StringBuilder?",
    "look_for": "Understanding of immutability and performance implications.",
    "answer": "**String** in Java/Kotlin is immutable - once created, its value cannot be changed. Any \"modification\" like concatenation creates a new String object in memory, leaving the original unchanged for garbage collection. This makes repeated concatenation inefficient: `var result = \"\"; for(i in 1..1000) result += i` creates 1000 String objects. **StringBuilder** (not thread-safe, faster) and **StringBuffer** (thread-safe via synchronized methods, slower) are mutable alternatives that modify content in-place without creating new objects. **Use StringBuilder** for building strings incrementally: `StringBuilder().append(\"Hello\").append(\" \").append(\"World\").toString()`, especially in loops. **Kotlin improvements**: String templates (`\"Hello $name, you are $age years old\"`) are compiler-optimized and more readable than concatenation; for simple cases, the compiler uses StringBuilder automatically. Use String for immutable text, StringBuilder for dynamic string construction, especially in performance-critical code.",
    "short_answer": "String is immutable (cannot be changed after creation). StringBuilder is mutable and more efficient for string concatenation in loops."
  },
  {
    "id": 24,
    "level": "junior",
    "question": "What is SharedPreferences?",
    "look_for": "Knowledge of when to use SharedPreferences vs database, understanding of commit vs apply.",
    "answer": "**SharedPreferences** provides lightweight, persistent key-value storage for primitive data types (boolean, int, float, long, String, Set<String>) that survives across app sessions. Data is stored as XML in the app's private storage (`/data/data/com.package/shared_prefs/`). **Access methods**: `getSharedPreferences(name, Context.MODE_PRIVATE)` for named files, or `PreferenceManager.getDefaultSharedPreferences(context)` for default file. **Writing data**: get Editor, add data, save: `editor.putString(\"key\", value).putInt(\"count\", 42).apply()`. **commit() vs apply()**: commit() writes synchronously (blocks thread, returns boolean success), apply() writes asynchronously to background thread (faster, no return value). **Reading**: `prefs.getString(\"key\", defaultValue)`. **Use cases**: user preferences, settings, simple flags, small cached data. **Not suitable for**: large data, structured data, sensitive data (use EncryptedSharedPreferences for secrets). **Modern alternative**: Jetpack DataStore (Preferences DataStore or Proto DataStore) offers type-safety, coroutines/Flow support, and handles disk I/O on background thread automatically.",
    "short_answer": "SharedPreferences stores small amounts of primitive data as key-value pairs in a file, persisting across app sessions."
  },
  {
    "id": 25,
    "level": "junior",
    "question": "What is the difference between finish() and finishAffinity()?",
    "look_for": "Basic understanding of activity stack and task management.",
    "answer": "**finish()** closes only the current activity, popping it from the back stack and triggering the lifecycle sequence: onPause() → onStop() → onDestroy(). Control returns to the previous activity on the stack, which resumes (onRestart() → onStart() → onResume()). The activity instance is destroyed but the app process remains. Use for normal navigation like handling back button or completing a task. **finishAffinity()** (API 16+) closes the current activity AND all activities below it in the back stack that share the same task affinity (typically, all activities from your app in the current task). This effectively clears your entire app from the task. **Use cases for finishAffinity()**: logout flows (clear all screens), exit app entirely, security-sensitive scenarios where you don't want previous screens accessible. **Important**: neither method kills the app process - they just remove activities from the UI stack. The process may continue running in the background with services or be kept alive by the system.",
    "short_answer": "finish() closes the current activity. finishAffinity() closes the current activity and all activities in the same task affinity below it."
  },
  {
    "id": 26,
    "level": "junior",
    "question": "What is ConstraintLayout?",
    "look_for": "Understanding of constraints, chains, and guidelines for responsive design.",
    "answer": "**ConstraintLayout** is a powerful, flexible layout manager that enables creating complex, responsive UIs with flat view hierarchies (avoiding nested layouts that harm performance). Views are positioned by defining constraints - relationships to other views, parent edges, or guidelines. Each view needs at least one horizontal and one vertical constraint. **Key features**: **Chains** (distribute multiple views evenly - styles: spread, spread_inside, packed with bias), **Guidelines** (invisible lines for alignment - vertical/horizontal, positioned by dp or percentage), **Barriers** (virtual boundary based on multiple view positions), **Groups** (control visibility of multiple views together), **Bias** (percentage-based positioning between constraints, 0.0-1.0), **Aspect ratio** (`app:layout_constraintDimensionRatio=\"16:9\"`), **Circular positioning** (position relative to angle/radius). **Benefits**: flatter hierarchies = faster rendering, visual editor in Android Studio with drag-and-drop, easier responsive design, reduces need for nested LinearLayouts/RelativeLayouts. **Example**: `app:layout_constraintTop_toBottomOf=\"@id/header\"` positions view's top below header's bottom.",
    "short_answer": "ConstraintLayout is a flexible layout that allows you to create complex layouts with a flat view hierarchy by positioning views relative to each other or parent."
  },
  {
    "id": 27,
    "level": "junior",
    "question": "What is an AlertDialog?",
    "look_for": "Knowledge of dialog builder pattern and handling button clicks.",
    "answer": "**AlertDialog** is a modal dialog that interrupts the user flow to display critical information or request decisions/input. **Structure**: optional title (`setTitle()`), message or custom view (`setMessage()` or `setView()`), and up to three buttons: Positive (\"OK\", \"Save\"), Negative (\"Cancel\", \"Delete\"), Neutral (\"Later\", \"Remind Me\"). Created via Builder pattern: `AlertDialog.Builder(context).setTitle(\"Confirm\").setMessage(\"Delete this item?\").setPositiveButton(\"Delete\") { dialog, which -> /* handle */ }.setNegativeButton(\"Cancel\") { dialog, which -> dialog.dismiss() }.setCancelable(false).show()`. **Default behavior**: buttons auto-dismiss dialog; call `setCancelable(false)` to prevent back button/outside-touch dismissal. **Custom layouts**: use `setView(R.layout.custom_dialog)` for complex UI. **Modern best practice**: use **DialogFragment** instead of direct AlertDialog - it properly handles configuration changes, lifecycle, and Fragment transaction management. AlertDialog is appropriate for simple confirmations, errors, or brief choices, but use sparingly as dialogs interrupt user flow.",
    "short_answer": "AlertDialog is a modal dialog that can display a title, message, and up to three buttons for user interaction."
  },
  {
    "id": 28,
    "level": "junior",
    "question": "What is the difference between Visibility.GONE and Visibility.INVISIBLE?",
    "look_for": "Understanding of layout impact and when to use each.",
    "answer": "Android views have three visibility states controlled by the `visibility` property: **View.VISIBLE** (value: 0, default) - view is rendered and occupies space in the layout, fully interactive. **View.INVISIBLE** (value: 4) - view is hidden/transparent but still occupies its space in the layout, creating a gap where it would be; useful for maintaining layout structure while hiding content. **View.GONE** (value: 8) - view is completely removed from the layout, takes up no space, and other views reflow to fill the gap; the view is not measured or laid out. **Setting**: `view.visibility = View.GONE` or XML: `android:visibility=\"gone\"`. **Use GONE** when you want the layout to adapt to the missing view (responsive behavior); **use INVISIBLE** when you want to maintain spacing/positioning but hide content temporarily. Changing visibility triggers a layout pass (expensive for complex hierarchies). **Animation**: Use TransitionManager, MotionLayout, or custom animations for smooth visibility transitions. **Performance**: GONE views skip measurement/layout, making complex layouts with many GONE views more performant.",
    "short_answer": "INVISIBLE hides the view but still takes up space in the layout. GONE hides the view and removes it from the layout, taking up no space."
  },
  {
    "id": 29,
    "level": "junior",
    "question": "What is a BroadcastReceiver?",
    "look_for": "Understanding of registering receivers statically vs dynamically.",
    "answer": "**BroadcastReceiver** is an Android component that listens for and responds to broadcast messages (Intents) from the system or other apps. **System broadcasts**: BOOT_COMPLETED (device startup), BATTERY_LOW/BATTERY_OKAY, CONNECTIVITY_CHANGE (network state), ACTION_PACKAGE_ADDED/REMOVED (app installed/uninstalled), ACTION_SCREEN_ON/OFF, etc. Apps can also send custom broadcasts via `sendBroadcast(intent)`. **Registration types**: **1) Static/Manifest registration** - declared in AndroidManifest.xml with `<receiver>` tag and `<intent-filter>`, receives broadcasts even when app is closed. **Heavily restricted since Android 8.0 (Oreo)** - most implicit broadcasts can't wake app, only few exceptions like BOOT_COMPLETED. **2) Dynamic/Context registration** - registered in code via `registerReceiver(receiver, intentFilter)` in onCreate/onResume, must unregister in onDestroy/onPause to prevent memory leaks. Only receives while registered. **Implementation**: extend BroadcastReceiver, override `onReceive(context, intent)`. **Limitations**: onReceive() runs on main thread (keep work under 10s to avoid ANR). **Modern alternative**: WorkManager for deferrable background work with constraints.",
    "short_answer": "A component that responds to system-wide broadcast announcements like battery low, network changes, or custom broadcasts from your app."
  },
  {
    "id": 30,
    "level": "junior",
    "question": "What is the purpose of onResume() method?",
    "look_for": "Understanding of when activity becomes visible vs interactive.",
    "answer": "**onResume()** is called when the activity is about to start actively interacting with the user - it's now fully visible, in the foreground, and receiving input events. This is the \"running\" state where the activity is interactive. **When called**: Always follows onStart(), called every time the activity returns to foreground from background (after onPause triggered by dialogs, lock screen, another activity, split-screen change). **What to do here**: Start animations/videos, begin location updates, acquire exclusive hardware resources (camera, sensors), register listeners that were unregistered in onPause, resume any paused operations, refresh content from network/database if data might be stale, start timers/countdowns. **Pairing with onPause**: Operations started in onResume() should be reversed in onPause() for symmetry - this pair represents the activity becoming interactive/losing interactivity. Keep code lightweight as onResume() blocks the UI thread. **Lifecycle guarantee**: onResume() always called before activity is interactive, making it the right place to start user-facing operations. After onResume(), activity is in resumed state until onPause() is called.",
    "short_answer": "onResume() is called when the activity is about to start interacting with the user. It's where you should start animations, resume paused tasks, or refresh content."
  },
  {
    "id": 31,
    "level": "junior",
    "question": "What is the difference between Service and Activity?",
    "look_for": "Understanding of when to use each component.",
    "answer": "**Activity** is a visual component representing a single screen with a user interface - it handles user interaction, displays content, and has its own lifecycle (onCreate, onResume, etc.). Activities are the entry points for user engagement, users navigate between them, and they're placed on the back stack. Each activity is relatively short-lived and can be destroyed by the system. **Service** is a non-visual component that performs long-running operations in the background without a user interface - examples include music playback, file downloads, data synchronization, network operations. Services continue running even when user switches apps. **Types**: Started service (runs independently until work completes), Bound service (provides client-server interface). **Key distinction**: Activity = UI + user interaction; Service = background work, no UI. Both run on the main thread by default, so services must offload heavy work to background threads. **Modern note**: For most background tasks, WorkManager is now preferred over services.",
    "short_answer": "Activity provides a UI for user interaction. Service runs in the background without a UI for long-running operations."
  },
  {
    "id": 32,
    "level": "junior",
    "question": "What is findViewById()?",
    "look_for": "Understanding of type casting and that ViewBinding is now preferred.",
    "answer": "findViewById() is a method to get a reference to a View from XML layout by its ID. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "findViewById() is a method to get a reference to a View from XML layout by its ID."
  },
  {
    "id": 33,
    "level": "junior",
    "question": "What is the main thread in Android?",
    "look_for": "Understanding of threading and why to keep main thread responsive.",
    "answer": "**The** main thread (UI thread) handles all UI updates and user interactions. Long operations should not run on it to avoid ANR. This is a fundamental concept in Android development that developers should understand for building robust applications.",
    "short_answer": "The main thread (UI thread) handles all UI updates and user interactions. Long operations should not run on it to avoid ANR."
  },
  {
    "id": 34,
    "level": "junior",
    "question": "What is the difference between a Fragment and an Activity?",
    "look_for": "Basic understanding of fragments as modular UI components.",
    "answer": "**Activity** represents a complete, full-screen UI - it's an independent entry point with its own lifecycle, typically corresponding to one screen in your app's flow. Each activity is a separate component declared in the manifest. **Fragment** is a modular, reusable portion of a UI that must be hosted within an Activity (or another Fragment) - it represents a behavior or piece of the interface. **Benefits of Fragments**: **1) Reusability** - same fragment can be used in multiple activities, **2) Modularity** - break complex UIs into manageable pieces, **3) Dynamic UI** - add/remove/replace fragments at runtime via FragmentTransaction, **4) Multi-pane layouts** - show multiple fragments side-by-side on tablets, single-pane on phones, **5) Back stack management** - fragments can be added to back stack for navigation. **Lifecycle**: Fragments have their own lifecycle (onCreateView, onViewCreated, onDestroyView, etc.) nested within the host activity's lifecycle. **Modern architecture**: Single-Activity apps with Navigation component use one Activity hosting multiple Fragments, reducing overhead and simplifying navigation.",
    "short_answer": "Activity represents a full screen with UI. Fragment is a reusable portion of UI that must be hosted in an Activity or another Fragment."
  },
  {
    "id": 35,
    "level": "junior",
    "question": "What is a PendingIntent?",
    "look_for": "Understanding of use cases like notifications and alarm manager.",
    "answer": "**PendingIntent** is a wrapper/token around an Intent that grants a foreign application permission to execute the contained Intent with your app's permissions and identity at a future time, as if your app performed the action. It's essentially a \"permission slip\" for another app to run your intent later. **Common use cases**: **1) Notifications** - tapping notification triggers your PendingIntent to open an activity, **2) AlarmManager** - schedule intents to fire at specific times, **3) App Widgets** - handle widget button clicks (widgets run in another process), **4) Geofencing** - trigger actions when entering/leaving locations. **Types**: `PendingIntent.getActivity()` (starts Activity), `PendingIntent.getService()` (starts Service), `PendingIntent.getBroadcast()` (sends broadcast). **Flags**: `FLAG_UPDATE_CURRENT` (update existing), `FLAG_ONE_SHOT` (use once), `FLAG_IMMUTABLE` (Android 12+ security requirement - intent can't be modified), `FLAG_CANCEL_CURRENT` (cancel existing). **Security**: Always use FLAG_IMMUTABLE unless you need mutability, and make intents explicit to prevent hijacking.",
    "short_answer": "PendingIntent is a token that you give to another application to perform an action on your app's behalf with your permissions."
  },
  {
    "id": 36,
    "level": "junior",
    "question": "What is the difference between margin and padding?",
    "look_for": "Visual understanding of layout spacing.",
    "answer": "Margin is the space outside a view's border. Padding is the space inside a view's border between the border and content. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a fundamental concept that every Android developer should master early in their learning journey.",
    "short_answer": "Margin is the space outside a view's border. Padding is the space inside a view's border between the border and content."
  },
  {
    "id": 37,
    "level": "junior",
    "question": "What is onDestroy() method?",
    "look_for": "Understanding of cleanup responsibilities and when it's called.",
    "answer": "**onDestroy()** is the final lifecycle callback invoked before an activity is completely destroyed and removed from memory, marking the end of the activity's lifecycle. **When called**: 1) User explicitly finishes activity (back button, finish() called), 2) System destroys activity due to configuration change (rotation, locale change) - immediately recreated afterward, 3) System needs to reclaim memory and destroys background activities. **Purpose**: Perform final cleanup to prevent resource leaks: close database connections, unregister broadcast receivers (if not done in onPause/onStop), cancel running coroutines/jobs, release memory-heavy resources, stop services, clear listeners. **Critical warning**: **onDestroy() is NOT guaranteed to be called** - if the system kills your app process due to extreme memory pressure, onDestroy() may not execute. Therefore, critical state-saving should happen in onPause() or onStop(), which ARE guaranteed. **After onDestroy()**: activity instance is eligible for garbage collection, all instance variables are cleared. If activity is recreated (configuration change), a new instance is created with onCreate() called again.",
    "short_answer": "onDestroy() is the final lifecycle callback before an activity is destroyed, used for cleanup like closing resources."
  },
  {
    "id": 38,
    "level": "junior",
    "question": "What is a Drawable in Android?",
    "look_for": "Knowledge of different drawable types (BitmapDrawable, VectorDrawable, ShapeDrawable).",
    "answer": "**Drawable** is an abstract class representing anything that can be drawn on a Canvas - a general abstraction for \"something that can be drawn\". **Types**: **1) BitmapDrawable** - raster images (PNG, JPG, WebP, GIF) from drawable/ or mipmap/ folders, **2) VectorDrawable** - XML-defined vector graphics (scalable without quality loss, smaller size), uses path data, **3) ShapeDrawable** - programmatically defined shapes (rectangles, ovals, lines), **4) GradientDrawable** - gradients, solid colors, rounded corners, strokes - defined in XML or code, **5) LayerDrawable** - stack multiple drawables on top of each other, **6) StateListDrawable** - different drawable for different states (pressed, focused, disabled, checked), **7) LevelListDrawable** - different drawables based on level value, **8) AnimationDrawable** - frame-by-frame animation, **9) TransitionDrawable** - crossfade between two drawables. **Access**: `ContextCompat.getDrawable(context, R.drawable.icon)` or `ResourcesCompat.getDrawable(resources, R.drawable.icon, theme)`. Drawables don't hold state - they're reusable graphical resources. Can be XML-defined or created programmatically.",
    "short_answer": "Drawable is a general abstraction for something that can be drawn, like bitmaps, shapes, colors, or vector graphics."
  },
  {
    "id": 39,
    "level": "junior",
    "question": "What is the difference between ArrayList and Array?",
    "look_for": "Understanding of when to use each based on size requirements.",
    "answer": "**Array** is a fixed-size, low-level data structure: `val array = arrayOf(1, 2, 3)` or `IntArray(5)`. **Characteristics**: Size immutable after creation (cannot add/remove elements), can hold primitives (int, float, boolean) directly without boxing, provides basic array operations, accessed via index (`array[0]`), fast access and iteration, memory-efficient for primitives. **ArrayList** (Java) / **MutableList** (Kotlin) is a dynamic, resizable collection: `val list = mutableListOf(1, 2, 3)` or `ArrayList<String>()`. **Characteristics**: Size dynamically changes (add/remove elements), can only hold objects (primitives are auto-boxed to Integer, Float, etc. with overhead), provides rich API (`add`, `remove`, `contains`, `indexOf`, `sort`, `filter`), backed by an array that auto-resizes when capacity exceeded, slightly slower than arrays due to method calls and potential resizing. **When to use**: **Array** for fixed-size collections, primitive arrays for performance-critical code, multi-dimensional arrays; **ArrayList/MutableList** for dynamic collections, when you need List interface methods, most general-purpose scenarios. Kotlin prefers lists: `listOf()` (immutable), `mutableListOf()` (mutable).",
    "short_answer": "Array has fixed size and can hold primitives or objects. ArrayList is dynamic, can only hold objects, and provides more methods."
  },
  {
    "id": 40,
    "level": "junior",
    "question": "What is a ViewHolder pattern?",
    "look_for": "Understanding of performance benefits and use in RecyclerView.",
    "answer": "**ViewHolder pattern** is a design pattern that caches references to views in a list item to avoid the expensive findViewById() operation during scrolling. **Problem**: In early ListView implementations, getView() would be called for every list item as user scrolls, and calling findViewById() for each view repeatedly traverses the entire view hierarchy - extremely expensive for fast scrolling through hundreds of items, causing laggy UI. **Solution**: ViewHolder class holds references to all views in an item layout. Created once in `onCreateViewHolder()` or when inflating a new view, then reused via view recycling - views that scroll off-screen are recycled for new data instead of creating new views. **RecyclerView mandates ViewHolder**: `RecyclerView.Adapter` requires ViewHolder pattern in its API - `onCreateViewHolder()` creates holder with view references, `onBindViewHolder()` updates existing views with new data. **Performance benefit**: Eliminates repeated findViewById() calls, enables smooth 60fps scrolling even with complex item layouts and large datasets. **Best practice**: ViewHolder should be lightweight, cache all necessary view references, and be reusable for different data.",
    "short_answer": "ViewHolder pattern caches view references to avoid repeatedly calling findViewById(), improving list scrolling performance."
  },
  {
    "id": 41,
    "level": "junior",
    "question": "What is the difference between == and .equals() in Java/Kotlin?",
    "look_for": "Understanding of reference vs value equality.",
    "answer": "== compares object references (same object in memory). .equals() compares object contents/values. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "== compares object references (same object in memory). .equals() compares object contents/values."
  },
  {
    "id": 42,
    "level": "junior",
    "question": "What is an AsyncTask?",
    "look_for": "Awareness that it's deprecated and knowledge of modern alternatives.",
    "answer": "**AsyncTask** was a helper class designed to simplify running background operations with UI updates - it provided callback methods running on worker thread (doInBackground) and main thread (onPreExecute, onProgressUpdate, onPostExecute). **Why deprecated in API 30 (Android 11)**: **1) Lifecycle issues** - easy to create memory leaks by holding activity references, difficult to cancel properly, not lifecycle-aware, **2) Complexity** - managing state across rotation/configuration changes was error-prone, **3) Thread management problems** - shared static thread pool could cause issues between different AsyncTasks, **4) Better alternatives emerged** - Kotlin Coroutines provide cleaner, more powerful async programming. **Modern alternatives**: **Kotlin Coroutines** (preferred) - `lifecycleScope.launch` or `viewModelScope.launch` with structured concurrency, automatic cancellation, easy main/background thread switching with Dispatchers, **RxJava/RxAndroid** for reactive programming, **Executors** with java.util.concurrent for low-level control, **WorkManager** for deferrable background tasks. **Migration**: Replace AsyncTask with coroutines: `lifecycleScope.launch { val result = withContext(Dispatchers.IO) { /* background work */ }; /* update UI with result */ }`.",
    "short_answer": "AsyncTask is a deprecated helper class for running short background operations and updating UI, now replaced by coroutines or RxJava."
  },
  {
    "id": 43,
    "level": "junior",
    "question": "What is the purpose of onPause() method?",
    "look_for": "Understanding of when to save state and release resources.",
    "answer": "**onPause()** is called when the activity is partially obscured or about to lose foreground status - user can still see it but it's no longer the focused, interactive activity. **Triggers**: Another activity starting (translucent/dialog-themed), multi-window mode change, dialog appearing, system dialog appearing (permissions, power dialog), or navigating to another app. Activity is still partially visible but not receiving input. **Purpose**: Perform lightweight, quick operations: pause animations/videos (continue in onResume), release exclusive resources (camera - other apps might need it, sensors), persist unsaved critical data (user edits, form data), pause location updates if not needed in background, stop UI updates. **Critical constraints**: **Keep code lightweight** - onPause() blocks the new activity from starting until it completes, so heavy operations delay user experience. If onPause() takes too long, it contributes to ANR. **No guaranteed onStop/onDestroy**: System may kill app process after onPause() without calling onStop() or onDestroy(), especially under memory pressure. Therefore, critical state-saving must happen in onPause(), not just onDestroy(). **Pairing**: Operations in onPause() should be reversed in onResume() - these methods are symmetric lifecycle pair representing interactive/non-interactive states.",
    "short_answer": "onPause() is called when the activity is partially obscured or about to lose focus. Used to pause animations, save persistent data."
  },
  {
    "id": 44,
    "level": "junior",
    "question": "What is a Notification in Android?",
    "look_for": "Knowledge of notification channels and importance levels.",
    "answer": "**Notification** is a message displayed in the notification drawer to alert users about app events or updates. This is a fundamental concept in Android development that developers should understand for building robust applications.",
    "short_answer": "Notification is a message displayed in the notification drawer to alert users about app events or updates."
  },
  {
    "id": 45,
    "level": "junior",
    "question": "What is the difference between Foreground and Background Service?",
    "look_for": "Understanding of when to use foreground service (music, navigation).",
    "answer": "**Foreground Service** displays a persistent, non-dismissible notification and runs with high priority (almost guaranteed not to be killed by system unless extreme memory pressure). Required by Android 8.0+ for ongoing, user-aware background operations. **Use cases**: Music/podcast playback, active navigation, fitness tracking, file upload/download with progress, ongoing call (VoIP). **Started with**: `startForeground(notificationId, notification)` within 5 seconds of starting service. **Must declare**: `<service>` in manifest with `android:foregroundServiceType` (mediaPlayback, location, camera, etc.) and request appropriate permission (FOREGROUND_SERVICE, plus type-specific like ACCESS_FINE_LOCATION). **Background Service** runs without notification at lower priority - system can kill it freely to reclaim resources. **Restrictions**: Since Android 8.0 (Oreo), starting background services from background is severely restricted - use WorkManager instead. Since Android 12 (API 31), foreground services have types and require specific permissions. **Key distinction**: Foreground service = user knows it's running (notification), high priority, for user-aware work; Background service = hidden, low priority, easily killed. For most background tasks, prefer **WorkManager** (deferrable, constraint-based) over services.",
    "short_answer": "Foreground service shows a persistent notification and is less likely to be killed. Background service runs without notification."
  },
  {
    "id": 46,
    "level": "junior",
    "question": "What is a MenuInflater?",
    "look_for": "Understanding of how to create and handle menu items.",
    "answer": "MenuInflater inflates menu XML resources into Menu objects for options menus, context menus, or popup menus. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "MenuInflater inflates menu XML resources into Menu objects for options menus, context menus, or popup menus."
  },
  {
    "id": 47,
    "level": "junior",
    "question": "What is the difference between val and var in Kotlin?",
    "look_for": "Understanding of immutability and preference for val when possible.",
    "answer": "In Kotlin, **val** declares an immutable (read-only) reference - the reference cannot be reassigned after initialization, similar to Java's `final`. **var** declares a mutable reference - the reference can be reassigned to different values. **Examples**: `val x = 5; x = 6` causes compilation error. `var y = 5; y = 6` works fine. **Important nuance**: **val means immutable reference, NOT immutable object** - `val list = mutableListOf(1, 2, 3); list.add(4)` is valid (list contents change, but list reference doesn't). To have immutable contents, use immutable collections: `val list = listOf(1, 2, 3)`. **Best practices**: **Prefer val by default** - immutability reduces bugs, makes code easier to reason about, enables compiler optimizations, supports functional programming style. Only use var when you genuinely need to reassign the reference. Kotlin's emphasis on immutability with val encourages safer, more maintainable code compared to Java where everything is mutable by default. **Val members**: can be overridden in subclasses, can have custom getters (computed properties), but cannot have setters.",
    "short_answer": "val is immutable (read-only, like final in Java). var is mutable and can be reassigned."
  },
  {
    "id": 48,
    "level": "junior",
    "question": "What is a ContentResolver?",
    "look_for": "Basic understanding of content provider interaction.",
    "answer": "**ContentResolver** provides access to content from ContentProviders, allowing you to query, insert, update, or delete data. This is a fundamental concept in Android development that developers should understand for building robust applications.",
    "short_answer": "ContentResolver provides access to content from ContentProviders, allowing you to query, insert, update, or delete data."
  },
  {
    "id": 49,
    "level": "junior",
    "question": "What is the application class in Android?",
    "look_for": "Understanding of when to use for singletons and initialization.",
    "answer": "**Application** class is a base class for maintaining global application state - it's a singleton that represents your entire app and exists as long as the app process lives. **Lifecycle**: `onCreate()` called when app process starts, before any other component (activities, services, etc.) is created. It's the first thing created and last thing destroyed. **Use cases**: **1) App-wide initialization** - initialize logging libraries (Timber), crash reporting (Firebase Crashlytics), dependency injection frameworks (Hilt, Koin), image loading libraries (Coil, Glide), **2) Singleton instances** - though modern architecture prefers DI and ViewModels, **3) Global state/configuration** - though this is discouraged, prefer ViewModel/Repository pattern. **Creating custom Application**: Extend Application, override `onCreate()`, declare in manifest: `<application android:name=\".MyApp\">`. **Warnings**: **Avoid heavy initialization** in Application.onCreate() - it blocks app startup, slowing cold start time. Use lazy initialization or App Startup library for complex initialization. **State limitations**: Application instance survives all activities/fragments but NOT process death - don't store UI state here. **Context**: Application provides Context that survives entire app lifecycle, safe for singletons, but lacks UI theme/resources available in Activity Context.",
    "short_answer": "Application class is the base class that maintains global application state, created before any other component."
  },
  {
    "id": 50,
    "level": "junior",
    "question": "What is a ScrollView?",
    "look_for": "Knowledge that it should have only one direct child and limitations with RecyclerView.",
    "answer": "**ScrollView** is a layout container that provides vertical scrolling capability when its content exceeds the screen height, enabling users to scroll up/down to view all content. **Key constraint**: Can have only ONE direct child - typically wrap content in LinearLayout, ConstraintLayout, or other container holding multiple views: `<ScrollView><LinearLayout>...children...</LinearLayout></ScrollView>`. **Horizontal counterpart**: HorizontalScrollView for left-right scrolling. **Important properties**: `android:fillViewport=\"true\"` makes child fill viewport even if smaller than screen (useful for centering content or bottom buttons), supports nested scrolling with CoordinatorLayout for collapsing toolbars. **Limitations**: **Cannot nest ScrollViews** (breaks touch event handling), **cannot contain ListView/RecyclerView** (conflicting scroll behaviors - use RecyclerView.NestedScrollView or single RecyclerView with header/footer). **Programmatic scrolling**: `scrollTo(x, y)` instant, `smoothScrollTo(x, y)` animated, `fullScroll(View.FOCUS_DOWN)` scroll to bottom. **Modern alternative**: **NestedScrollView** (same as ScrollView but supports nested scrolling with CoordinatorLayout for Material Design behaviors like collapsing toolbars). **Use cases**: Long forms, terms and conditions, article content, settings screens - any static content that might exceed screen height.",
    "short_answer": "ScrollView is a layout container that allows content to be scrolled vertically when it exceeds screen height."
  },
  {
    "id": 51,
    "level": "mid",
    "question": "Explain the difference between Serializable and Parcelable.",
    "look_for": "Understanding of performance differences and when to use each.",
    "answer": "Both pass objects between components. Parcelable is Android-specific and faster, while Serializable is Java standard but slower. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. **Trade-offs**: Each approach has different performance characteristics, memory footprint, and API requirements. Consider your specific constraints when choosing.",
    "short_answer": "Both pass objects between components. Parcelable is Android-specific and faster, while Serializable is Java standard but slower."
  },
  {
    "id": 52,
    "level": "mid",
    "question": "What is the difference between Service and IntentService?",
    "look_for": "Understanding of threading implications and that IntentService is now deprecated.",
    "answer": "**Service** runs on the main thread. IntentService automatically runs tasks on a background thread and stops itself when done. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers. Since this approach is deprecated, modern Android development uses alternatives like Kotlin Coroutines, Flow, or WorkManager, which provide better lifecycle awareness, error handling, and performance.",
    "short_answer": "Service runs on the main thread. IntentService automatically runs tasks on a background thread and stops itself when done."
  },
  {
    "id": 53,
    "level": "mid",
    "question": "Explain Android's memory management.",
    "look_for": "Understanding of memory limitations, knowledge of memory leaks, familiarity with profiling tools.",
    "answer": "Android uses ART runtime with garbage collection. Each app runs in its own process with limited heap size. System can kill background processes when memory is low. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Android uses ART runtime with garbage collection. Each app runs in its own process with limited heap size. System can kill background processes when memory is low."
  },
  {
    "id": 54,
    "level": "mid",
    "question": "What are Fragments and why use them?",
    "look_for": "Understanding of Fragment lifecycle and FragmentManager.",
    "answer": "Fragments are reusable UI portions with their own lifecycle. They allow modular screen designs and tablet optimization. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Fragments are reusable UI portions with their own lifecycle. They allow modular screen designs and tablet optimization."
  },
  {
    "id": 55,
    "level": "mid",
    "question": "Explain different types of Context in Android.",
    "look_for": "Understanding of context lifetime and memory leak risks.",
    "answer": "Android provides several **Context** types: **1) Application Context** (`applicationContext`) - singleton tied to app lifecycle, survives entire process, safe for app-wide operations but lacks UI theme/resources. **2) Activity Context** (`this` in Activity) - tied to activity lifecycle, includes UI theme and resources, required for UI operations like inflating views, showing dialogs, but can cause leaks if held beyond activity lifetime. **3) Service Context** - tied to service lifecycle. **4) BroadcastReceiver Context** - temporary context in onReceive(). **Key rule**: Use Application Context for singletons/long-lived objects to avoid memory leaks; use Activity Context for UI operations, dialogs, toasts, theme-dependent operations. Passing wrong context can cause crashes or theme issues.",
    "short_answer": "Application Context (app lifetime), Activity Context (activity lifetime), and Service Context. Use appropriately to avoid memory leaks."
  },
  {
    "id": 56,
    "level": "mid",
    "question": "What is RecyclerView and how does it differ from ListView?",
    "look_for": "Understanding of ViewHolder pattern and knowledge of LayoutManager types.",
    "answer": "**RecyclerView** is a flexible list view with built-in ViewHolder pattern, layout managers, and item animations. More efficient than ListView. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "RecyclerView is a flexible list view with built-in ViewHolder pattern, layout managers, and item animations. More efficient than ListView."
  },
  {
    "id": 57,
    "level": "mid",
    "question": "Explain the MVVM architecture pattern.",
    "look_for": "Practical experience implementing MVVM and knowledge of LiveData/StateFlow.",
    "answer": "Model-View-**ViewModel** separates UI (View), business logic (**ViewModel**), and data (Model). ViewModel survives configuration changes. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Model-View-ViewModel separates UI (View), business logic (ViewModel), and data (Model). ViewModel survives configuration changes."
  },
  {
    "id": 58,
    "level": "mid",
    "question": "What is LiveData?",
    "look_for": "Understanding of lifecycle awareness and when to use LiveData vs StateFlow.",
    "answer": "**LiveData** is an observable data holder that's lifecycle-aware, automatically updating UI components when data changes. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "LiveData is an observable data holder that's lifecycle-aware, automatically updating UI components when data changes."
  },
  {
    "id": 59,
    "level": "mid",
    "question": "What is ViewModel and why use it?",
    "look_for": "Understanding of ViewModel lifecycle and scope, knowledge of ViewModelProvider.",
    "answer": "**ViewModel** stores and manages UI-related data that survives configuration changes like screen rotations. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "ViewModel stores and manages UI-related data that survives configuration changes like screen rotations."
  },
  {
    "id": 60,
    "level": "mid",
    "question": "What is Room database?",
    "look_for": "Knowledge of Entity, DAO, and Database components, understanding of database migrations.",
    "answer": "**Room** is an abstraction layer over SQLite that provides compile-time verification of SQL queries and simplifies database operations. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Room is an abstraction layer over SQLite that provides compile-time verification of SQL queries and simplifies database operations."
  },
  {
    "id": 61,
    "level": "mid",
    "question": "What is the difference between ArrayList and LinkedList?",
    "look_for": "Understanding of time complexity and choosing appropriate data structure.",
    "answer": "ArrayList uses dynamic array (fast random access). LinkedList uses doubly-linked list (faster insertion/deletion). **Trade-offs**: Each approach has different performance characteristics, memory footprint, and API requirements. Consider your specific constraints when choosing. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "ArrayList uses dynamic array (fast random access). LinkedList uses doubly-linked list (faster insertion/deletion)."
  },
  {
    "id": 62,
    "level": "mid",
    "question": "What is Retrofit?",
    "look_for": "Experience with API integration, knowledge of converters and interceptors.",
    "answer": "**Retrofit** is a type-safe HTTP client for Android that simplifies REST API calls and handles JSON parsing. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Retrofit is a type-safe HTTP client for Android that simplifies REST API calls and handles JSON parsing."
  },
  {
    "id": 63,
    "level": "mid",
    "question": "What is the difference between AsyncTask and Coroutines?",
    "look_for": "Understanding that AsyncTask is deprecated and preference for modern alternatives.",
    "answer": "AsyncTask is deprecated and runs on background threads with complex lifecycle. Coroutines are lightweight, simpler, and provide structured concurrency. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers.",
    "short_answer": "AsyncTask is deprecated and runs on background threads with complex lifecycle. Coroutines are lightweight, simpler, and provide structured concurrency."
  },
  {
    "id": 64,
    "level": "mid",
    "question": "What is Glide or Picasso?",
    "look_for": "Experience with image loading, understanding of caching strategies.",
    "answer": "Image loading libraries that handle downloading, caching, and displaying images efficiently with memory management. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Image loading libraries that handle downloading, caching, and displaying images efficiently with memory management."
  },
  {
    "id": 65,
    "level": "mid",
    "question": "What is ProGuard/R8?",
    "look_for": "Understanding of release builds, knowledge of keep rules for reflection-based libraries.",
    "answer": "Code obfuscation and optimization tools that shrink, optimize, and obfuscate code to reduce APK size and improve security. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Code obfuscation and optimization tools that shrink, optimize, and obfuscate code to reduce APK size and improve security."
  },
  {
    "id": 66,
    "level": "mid",
    "question": "What is the difference between MVC, MVP, and MVVM?",
    "look_for": "Understanding of separation of concerns and testability benefits.",
    "answer": "**MVC**: Controller handles logic. **MVP**: Presenter handles logic with interface. MVVM: ViewModel with data binding and lifecycle awareness. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers.",
    "short_answer": "MVC: Controller handles logic. MVP: Presenter handles logic with interface. MVVM: ViewModel with data binding and lifecycle awareness."
  },
  {
    "id": 67,
    "level": "mid",
    "question": "What is WorkManager?",
    "look_for": "Understanding of when to use WorkManager vs other background solutions.",
    "answer": "**WorkManager** is a library for deferrable, guaranteed background work that respects system constraints and survives app restarts. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "WorkManager is a library for deferrable, guaranteed background work that respects system constraints and survives app restarts."
  },
  {
    "id": 68,
    "level": "mid",
    "question": "What is the Repository pattern?",
    "look_for": "Understanding of single source of truth and data layer abstraction.",
    "answer": "**Repository** mediates between data sources (network, database) and the rest of the app, providing a clean API for data access. This is a fundamental concept in Android development that developers should understand for building robust applications. This pattern promotes separation of concerns, improves testability, enhances code maintainability, and makes the codebase more scalable and easier to understand.",
    "short_answer": "Repository mediates between data sources (network, database) and the rest of the app, providing a clean API for data access."
  },
  {
    "id": 69,
    "level": "mid",
    "question": "What is Dependency Injection?",
    "look_for": "Familiarity with DI frameworks like Dagger, Hilt, or Koin.",
    "answer": "A design pattern where dependencies are provided to classes rather than created by them, improving testability and modularity. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "A design pattern where dependencies are provided to classes rather than created by them, improving testability and modularity."
  },
  {
    "id": 70,
    "level": "mid",
    "question": "What is the difference between Handler and HandlerThread?",
    "look_for": "Understanding of message queue and when to use for background operations.",
    "answer": "Handler posts messages to a thread's message queue. HandlerThread is a Thread with a Looper for handling messages sequentially. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. **Trade-offs**: Each approach has different performance characteristics, memory footprint, and API requirements. Consider your specific constraints when choosing.",
    "short_answer": "Handler posts messages to a thread's message queue. HandlerThread is a Thread with a Looper for handling messages sequentially."
  },
  {
    "id": 71,
    "level": "mid",
    "question": "What is DiffUtil in RecyclerView?",
    "look_for": "Understanding of performance benefits and implementation of areItemsTheSame and areContentsTheSame.",
    "answer": "DiffUtil calculates the difference between two lists and outputs a list of update operations that efficiently updates the **RecyclerView**. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "DiffUtil calculates the difference between two lists and outputs a list of update operations that efficiently updates the RecyclerView."
  },
  {
    "id": 72,
    "level": "mid",
    "question": "What is ViewBinding?",
    "look_for": "Understanding of benefits over findViewById and difference from DataBinding.",
    "answer": "**ViewBinding** generates binding classes for XML layouts, providing type-safe access to views without findViewById and reducing null pointer exceptions. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "ViewBinding generates binding classes for XML layouts, providing type-safe access to views without findViewById and reducing null pointer exceptions."
  },
  {
    "id": 73,
    "level": "mid",
    "question": "What is the Navigation Component?",
    "look_for": "Experience with navigation graph, SafeArgs, and handling navigation actions.",
    "answer": "A Jetpack library that handles fragment transactions, back stack management, deep links, and safe argument passing with a visual navigation graph. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "A Jetpack library that handles fragment transactions, back stack management, deep links, and safe argument passing with a visual navigation graph."
  },
  {
    "id": 74,
    "level": "mid",
    "question": "What is the difference between HashMap and ArrayMap?",
    "look_for": "Understanding of Android-specific collections and memory optimization.",
    "answer": "HashMap uses more memory but faster for large datasets. ArrayMap is memory-efficient for small datasets (< 1000 items) but slower for large ones. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "HashMap uses more memory but faster for large datasets. ArrayMap is memory-efficient for small datasets (< 1000 items) but slower for large ones."
  },
  {
    "id": 75,
    "level": "mid",
    "question": "What is Paging library?",
    "look_for": "Experience with PagingSource, PagingData, and integration with RecyclerView.",
    "answer": "Paging library helps load and display large datasets gradually, loading data in chunks to reduce memory usage and network bandwidth. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Paging library helps load and display large datasets gradually, loading data in chunks to reduce memory usage and network bandwidth."
  },
  {
    "id": 76,
    "level": "mid",
    "question": "What is the difference between lateinit and lazy?",
    "look_for": "Understanding of Kotlin initialization patterns and when to use each.",
    "answer": "**lateinit** is for var properties initialized later, throws exception if accessed before initialization. **lazy** is for val properties with initialization code run on first access. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "lateinit is for var properties initialized later, throws exception if accessed before initialization. lazy is for val properties with initialization code run on first access."
  },
  {
    "id": 77,
    "level": "mid",
    "question": "What is DataBinding?",
    "look_for": "Experience with binding adapters, two-way binding, and understanding of generated code.",
    "answer": "**DataBinding** binds UI components in layouts directly to data sources using declarative format in XML, reducing boilerplate code. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "DataBinding binds UI components in layouts directly to data sources using declarative format in XML, reducing boilerplate code."
  },
  {
    "id": 78,
    "level": "mid",
    "question": "What is JobScheduler?",
    "look_for": "Understanding of when to use JobScheduler vs WorkManager (WorkManager is now preferred).",
    "answer": "JobScheduler schedules background jobs that run based on conditions like network availability, charging state, or device idle. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "JobScheduler schedules background jobs that run based on conditions like network availability, charging state, or device idle."
  },
  {
    "id": 79,
    "level": "mid",
    "question": "What is the difference between launch and async in coroutines?",
    "look_for": "Understanding of when to use each and how to await results from async.",
    "answer": "launch starts a coroutine that doesn't return a result (returns **Job**). async starts a coroutine that returns a result via **Deferred** (like a future). Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "launch starts a coroutine that doesn't return a result (returns Job). async starts a coroutine that returns a result via Deferred (like a future)."
  },
  {
    "id": 80,
    "level": "mid",
    "question": "What is SparseArray?",
    "look_for": "Understanding of Android-specific collections for memory optimization.",
    "answer": "SparseArray is an Android-optimized map for integer keys, more memory-efficient than HashMap<Integer, Object> for small to medium datasets. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "SparseArray is an Android-optimized map for integer keys, more memory-efficient than HashMap<Integer, Object> for small to medium datasets."
  },
  {
    "id": 81,
    "level": "mid",
    "question": "What is the difference between Coroutine Dispatchers?",
    "look_for": "Understanding of appropriate dispatcher usage for different operations.",
    "answer": "Dispatchers.Main for UI updates, Dispatchers.IO for network/disk operations, Dispatchers.Default for CPU-intensive work, Dispatchers.Unconfined for testing. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Dispatchers.Main for UI updates, Dispatchers.IO for network/disk operations, Dispatchers.Default for CPU-intensive work, Dispatchers.Unconfined for testing."
  },
  {
    "id": 82,
    "level": "mid",
    "question": "What is a sealed class in Kotlin?",
    "look_for": "Understanding of when expressions with sealed classes and state management.",
    "answer": "Sealed classes represent restricted class hierarchies where all subclasses are known at compile time, useful for representing state. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Sealed classes represent restricted class hierarchies where all subclasses are known at compile time, useful for representing state."
  },
  {
    "id": 83,
    "level": "mid",
    "question": "What is the difference between launch and lifecycleScope.launch?",
    "look_for": "Understanding of lifecycle-aware coroutine scopes and automatic cancellation.",
    "answer": "lifecycleScope.launch automatically cancels coroutines when the lifecycle owner is destroyed, preventing memory leaks and crashes. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers.",
    "short_answer": "lifecycleScope.launch automatically cancels coroutines when the lifecycle owner is destroyed, preventing memory leaks and crashes."
  },
  {
    "id": 84,
    "level": "mid",
    "question": "What is MotionLayout?",
    "look_for": "Experience with complex animations and understanding of KeyFrames and ConstraintSets.",
    "answer": "MotionLayout is a layout type that helps you manage motion and widget animation in your app, subclass of ConstraintLayout. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "MotionLayout is a layout type that helps you manage motion and widget animation in your app, subclass of ConstraintLayout."
  },
  {
    "id": 85,
    "level": "mid",
    "question": "What is the difference between cold and hot streams in Flow?",
    "look_for": "Understanding of StateFlow (hot) vs regular Flow (cold) use cases.",
    "answer": "Cold streams start emitting when collected and emit to one collector. Hot streams emit regardless of collectors and can have multiple collectors. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Cold streams start emitting when collected and emit to one collector. Hot streams emit regardless of collectors and can have multiple collectors."
  },
  {
    "id": 86,
    "level": "mid",
    "question": "What is a companion object in Kotlin?",
    "look_for": "Understanding of how it differs from Java static and @JvmStatic annotation.",
    "answer": "Companion object is an object tied to a class (not instance) that allows you to define static-like members and factory methods. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Companion object is an object tied to a class (not instance) that allows you to define static-like members and factory methods."
  },
  {
    "id": 87,
    "level": "mid",
    "question": "What is the difference between Mutable and Immutable collections in Kotlin?",
    "look_for": "Understanding that immutable doesn't mean truly immutable, just read-only interface.",
    "answer": "**Mutable** collections (MutableList, MutableSet) can be modified. **Immutable** collections (List, Set) are read-only interfaces. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Mutable collections (MutableList, MutableSet) can be modified. Immutable collections (List, Set) are read-only interfaces."
  },
  {
    "id": 88,
    "level": "mid",
    "question": "What is the difference between StateFlow and SharedFlow?",
    "look_for": "Understanding of when to use each, knowledge of replay cache and buffer configuration.",
    "answer": "**StateFlow** always has a value and replays the latest value to new collectors. **SharedFlow** can have zero or multiple replayed values and supports more configuration. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "StateFlow always has a value and replays the latest value to new collectors. SharedFlow can have zero or multiple replayed values and supports more configuration."
  },
  {
    "id": 89,
    "level": "mid",
    "question": "What is Hilt?",
    "look_for": "Experience with @HiltAndroidApp, @AndroidEntryPoint, and understanding of component hierarchy.",
    "answer": "**Hilt** is a dependency injection library built on top of **Dagger**, providing a standard way to incorporate DI in Android apps with less boilerplate. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Hilt is a dependency injection library built on top of Dagger, providing a standard way to incorporate DI in Android apps with less boilerplate."
  },
  {
    "id": 90,
    "level": "mid",
    "question": "What is the difference between apply and commit in SharedPreferences?",
    "look_for": "Understanding of when to use each based on need for immediate persistence or return value.",
    "answer": "apply() is asynchronous and doesn't return a result. commit() is synchronous, blocks the thread, and returns a boolean indicating success. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "apply() is asynchronous and doesn't return a result. commit() is synchronous, blocks the thread, and returns a boolean indicating success."
  },
  {
    "id": 91,
    "level": "mid",
    "question": "What is data class in Kotlin?",
    "look_for": "Understanding of auto-generated functions and when to use data classes.",
    "answer": "Data class automatically generates equals(), hashCode(), toString(), copy(), and componentN() functions for holding data. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Data class automatically generates equals(), hashCode(), toString(), copy(), and componentN() functions for holding data."
  },
  {
    "id": 92,
    "level": "mid",
    "question": "What is the difference between let, run, with, apply, and also in Kotlin?",
    "look_for": "Understanding of context object reference, return value, and appropriate use cases.",
    "answer": "let (it, returns lambda result), run (this, returns lambda result), with (this, returns lambda result), apply (this, returns context object), also (it, returns context object). Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "let (it, returns lambda result), run (this, returns lambda result), with (this, returns lambda result), apply (this, returns context object), also (it, returns context object)."
  },
  {
    "id": 93,
    "level": "mid",
    "question": "What is a Content URI?",
    "look_for": "Understanding of URI structure and how to query data using ContentResolver.",
    "answer": "Content URI is a URI that identifies data in a **ContentProvider**, following the pattern content://authority/path/id. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Content URI is a URI that identifies data in a ContentProvider, following the pattern content://authority/path/id."
  },
  {
    "id": 94,
    "level": "mid",
    "question": "What is the difference between Looper and Handler?",
    "look_for": "Understanding of message queue threading model.",
    "answer": "Looper runs a message loop in a thread. Handler posts messages to and processes messages from a Looper's message queue. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. **Trade-offs**: Each approach has different performance characteristics, memory footprint, and API requirements. Consider your specific constraints when choosing.",
    "short_answer": "Looper runs a message loop in a thread. Handler posts messages to and processes messages from a Looper's message queue."
  },
  {
    "id": 95,
    "level": "mid",
    "question": "What is OkHttp?",
    "look_for": "Experience with interceptors, connection pooling, and understanding it's used by Retrofit.",
    "answer": "OkHttp is an HTTP client for Android that efficiently handles connections, supports HTTP/2, connection pooling, and transparent GZIP compression. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "OkHttp is an HTTP client for Android that efficiently handles connections, supports HTTP/2, connection pooling, and transparent GZIP compression."
  },
  {
    "id": 96,
    "level": "mid",
    "question": "What is extension function in Kotlin?",
    "look_for": "Understanding of how they're resolved statically and practical use cases.",
    "answer": "Extension functions allow you to add new functions to existing classes without modifying their source code. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Extension functions allow you to add new functions to existing classes without modifying their source code."
  },
  {
    "id": 97,
    "level": "mid",
    "question": "What is the difference between onSaveInstanceState and ViewModel?",
    "look_for": "Understanding of when to use each and SavedStateHandle in ViewModel.",
    "answer": "onSaveInstanceState saves small amounts of data during process death. **ViewModel** survives configuration changes but not process death. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "onSaveInstanceState saves small amounts of data during process death. ViewModel survives configuration changes but not process death."
  },
  {
    "id": 98,
    "level": "mid",
    "question": "What is @Parcelize annotation in Kotlin?",
    "look_for": "Understanding that it requires kotlin-parcelize plugin and works with data classes.",
    "answer": "@Parcelize auto-generates **Parcelable** implementation for data classes, eliminating boilerplate code. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "@Parcelize auto-generates Parcelable implementation for data classes, eliminating boilerplate code."
  },
  {
    "id": 99,
    "level": "mid",
    "question": "What is the difference between FragmentPagerAdapter and FragmentStatePagerAdapter?",
    "look_for": "Understanding that both are deprecated in favor of ViewPager2 with FragmentStateAdapter.",
    "answer": "FragmentPagerAdapter keeps fragments in memory. FragmentStatePagerAdapter destroys fragments and saves state, better for many pages. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "FragmentPagerAdapter keeps fragments in memory. FragmentStatePagerAdapter destroys fragments and saves state, better for many pages."
  },
  {
    "id": 100,
    "level": "mid",
    "question": "What is Espresso?",
    "look_for": "Experience writing UI tests, understanding of ViewMatchers and ViewActions.",
    "answer": "Espresso is a UI testing framework for Android that provides APIs to write concise, reliable UI tests. This is a fundamental concept in Android development that developers should understand for building robust applications. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Espresso is a UI testing framework for Android that provides APIs to write concise, reliable UI tests."
  },
  {
    "id": 101,
    "level": "senior",
    "question": "Explain Android's multi-module architecture and its benefits.",
    "look_for": "Experience designing module dependencies, understanding of Gradle configuration, knowledge of dynamic delivery.",
    "answer": "Multi-module architecture divides app into feature modules, improving build times, reusability, and enforcing separation of concerns. Supports dynamic feature modules. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Multi-module architecture divides app into feature modules, improving build times, reusability, and enforcing separation of concerns. Supports dynamic feature modules."
  },
  {
    "id": 102,
    "level": "senior",
    "question": "What is Jetpack Compose and how does it differ from XML layouts?",
    "look_for": "Experience with Compose, understanding of recomposition, state management, and side effects.",
    "answer": "**Compose** is a declarative UI toolkit using Kotlin functions instead of XML. It simplifies UI development with reactive paradigm and eliminates need for findViewById. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Compose is a declarative UI toolkit using Kotlin functions instead of XML. It simplifies UI development with reactive paradigm and eliminates need for findViewById."
  },
  {
    "id": 103,
    "level": "senior",
    "question": "Explain the Clean Architecture principles in Android.",
    "look_for": "Understanding of use cases, entities, repository pattern, and dependency rule (inner layers don't know outer layers).",
    "answer": "Clean Architecture separates code into layers (Presentation, Domain, Data) with dependency inversion, making code testable, maintainable, and independent of frameworks. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Clean Architecture separates code into layers (Presentation, Domain, Data) with dependency inversion, making code testable, maintainable, and independent of frameworks."
  },
  {
    "id": 104,
    "level": "senior",
    "question": "What are coroutines channels and their use cases?",
    "look_for": "Understanding of channel types (rendezvous, buffered, conflated, unlimited), when to use over Flow.",
    "answer": "Channels are hot streams for communicating between coroutines, similar to blocking queues but suspending. Support different buffer strategies and closing. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Channels are hot streams for communicating between coroutines, similar to blocking queues but suspending. Support different buffer strategies and closing."
  },
  {
    "id": 105,
    "level": "senior",
    "question": "Explain the concept of structured concurrency in coroutines.",
    "look_for": "Understanding of CoroutineScope, Job hierarchy, exception handling, and supervision strategies.",
    "answer": "Structured concurrency ensures coroutines are organized in a hierarchy where parent waits for children, and cancellation propagates down, preventing leaks. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Structured concurrency ensures coroutines are organized in a hierarchy where parent waits for children, and cancellation propagates down, preventing leaks."
  },
  {
    "id": 106,
    "level": "senior",
    "question": "What is the difference between Flow and RxJava?",
    "look_for": "Understanding of when to use each, migration strategies, and performance considerations.",
    "answer": "**Flow** is Kotlin-native, cold by default, and integrated with coroutines. RxJava is Java-based, has more operators, and uses backpressure strategies. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Flow is Kotlin-native, cold by default, and integrated with coroutines. RxJava is Java-based, has more operators, and uses backpressure strategies."
  },
  {
    "id": 107,
    "level": "senior",
    "question": "How do you handle process death and state restoration?",
    "look_for": "Understanding of state restoration priority, testing with 'Don't keep activities', knowledge of SavedStateHandle.",
    "answer": "Combine **ViewModel** with SavedStateHandle for UI state, onSaveInstanceState for critical data, and **Room**/DataStore for persistent data. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Combine ViewModel with SavedStateHandle for UI state, onSaveInstanceState for critical data, and Room/DataStore for persistent data."
  },
  {
    "id": 108,
    "level": "senior",
    "question": "Explain Android's security best practices.",
    "look_for": "Understanding of encryption APIs, secure storage, network security config, and common vulnerabilities.",
    "answer": "Use HTTPS, implement certificate pinning, encrypt sensitive data, use Android Keystore, apply **ProGuard**/**R8**, validate inputs, use SafetyNet, implement proper permissions. Security is paramount in mobile development - always follow the principle of least privilege, validate inputs, encrypt sensitive data, and keep security libraries updated to protect user privacy and data. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Use HTTPS, implement certificate pinning, encrypt sensitive data, use Android Keystore, apply ProGuard/R8, validate inputs, use SafetyNet, implement proper permissions."
  },
  {
    "id": 109,
    "level": "senior",
    "question": "What is the difference between deep links, app links, and dynamic links?",
    "look_for": "Understanding of Digital Asset Links verification, intent filters, and handling navigation from links.",
    "answer": "Deep links open app via URL. App links are verified HTTP URLs that open app directly. Dynamic links are Firebase feature supporting cross-platform with analytics. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Deep links open app via URL. App links are verified HTTP URLs that open app directly. Dynamic links are Firebase feature supporting cross-platform with analytics."
  },
  {
    "id": 110,
    "level": "senior",
    "question": "Explain memory leaks in Android and how to prevent them.",
    "look_for": "Experience with LeakCanary, understanding of weak references, proper lifecycle management, and memory profiling.",
    "answer": "Memory leaks occur when objects are held in memory after they're no longer needed. Common causes: static references, non-static inner classes, listeners, handlers. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks.",
    "short_answer": "Memory leaks occur when objects are held in memory after they're no longer needed. Common causes: static references, non-static inner classes, listeners, handlers."
  },
  {
    "id": 111,
    "level": "senior",
    "question": "What is Gradle build optimization?",
    "look_for": "Understanding of build scan analysis, configuration cache, and impact of different dependency configurations.",
    "answer": "Enable build cache, use implementation vs api, enable parallel execution, use incremental builds, optimize dependency resolution, consider modularization. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Enable build cache, use implementation vs api, enable parallel execution, use incremental builds, optimize dependency resolution, consider modularization."
  },
  {
    "id": 112,
    "level": "senior",
    "question": "Explain Android's threading models and best practices.",
    "look_for": "Deep understanding of thread safety, race conditions, deadlocks, and modern concurrency patterns.",
    "answer": "Main thread for UI, worker threads for operations. Use coroutines with appropriate dispatchers, avoid blocking operations, implement proper cancellation. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Main thread for UI, worker threads for operations. Use coroutines with appropriate dispatchers, avoid blocking operations, implement proper cancellation."
  },
  {
    "id": 113,
    "level": "senior",
    "question": "What is App Startup library?",
    "look_for": "Understanding of initialization order, dependencies between initializers, and performance benefits over multiple ContentProviders.",
    "answer": "App Startup provides a performant way to initialize components at app launch, allowing sequential and parallel initialization with shared single **ContentProvider**. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "App Startup provides a performant way to initialize components at app launch, allowing sequential and parallel initialization with shared single ContentProvider."
  },
  {
    "id": 114,
    "level": "senior",
    "question": "Explain Android's rendering pipeline.",
    "look_for": "Understanding of Choreographer, VSYNC, GPU overdraw, and optimization techniques like reducing view hierarchy depth.",
    "answer": "Measure → Layout → Draw phases. UI thread prepares display lists, RenderThread rasterizes, and GPU composites layers. Target 16ms per frame for 60fps. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Measure → Layout → Draw phases. UI thread prepares display lists, RenderThread rasterizes, and GPU composites layers. Target 16ms per frame for 60fps."
  },
  {
    "id": 115,
    "level": "senior",
    "question": "What is the difference between MutableStateFlow and MutableSharedFlow?",
    "look_for": "Understanding of conflation behavior, appropriate use cases, and performance implications.",
    "answer": "MutableStateFlow requires initial value, conflates updates, replays latest value. MutableSharedFlow doesn't require initial value, configurable replay, supports multiple emissions. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "MutableStateFlow requires initial value, conflates updates, replays latest value. MutableSharedFlow doesn't require initial value, configurable replay, supports multiple emissions."
  },
  {
    "id": 116,
    "level": "senior",
    "question": "How do you implement offline-first architecture?",
    "look_for": "Experience with Repository pattern, understanding of data synchronization strategies, conflict resolution approaches.",
    "answer": "Use **Room** as single source of truth, sync with network, implement conflict resolution, queue operations when offline, use **WorkManager** for sync. Proper implementation requires understanding the underlying mechanisms and following Android best practices. In production environments, monitor this aspect closely, use analytics to measure impact, and iterate based on real-world usage patterns.",
    "short_answer": "Use Room as single source of truth, sync with network, implement conflict resolution, queue operations when offline, use WorkManager for sync."
  },
  {
    "id": 117,
    "level": "senior",
    "question": "Explain Android's permission system changes across versions.",
    "look_for": "Deep understanding of permission handling across versions, best practices for requesting permissions, alternative approaches.",
    "answer": "Runtime permissions (API 23), background location (API 29), scoped storage (API 29-30), permission dialogs changes (API 30), approximate location (API 31). Security is paramount in mobile development - always follow the principle of least privilege, validate inputs, encrypt sensitive data, and keep security libraries updated to protect user privacy and data. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Runtime permissions (API 23), background location (API 29), scoped storage (API 29-30), permission dialogs changes (API 30), approximate location (API 31)."
  },
  {
    "id": 118,
    "level": "senior",
    "question": "What is the Composition Local in Jetpack Compose?",
    "look_for": "Understanding of when to use, difference between staticCompositionLocalOf and compositionLocalOf, and alternatives.",
    "answer": "CompositionLocal provides implicit way to pass data down the composition tree without explicitly passing through every composable. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "CompositionLocal provides implicit way to pass data down the composition tree without explicitly passing through every composable."
  },
  {
    "id": 119,
    "level": "senior",
    "question": "Explain Android's testing pyramid.",
    "look_for": "Experience with JUnit, Mockito/MockK, Espresso, understanding of test doubles, and CI/CD integration.",
    "answer": "70% unit tests (fast, isolated), 20% integration tests (module interactions), 10% UI tests (end-to-end). Balance speed, reliability, and coverage. Effective testing ensures code quality, prevents regressions, facilitates refactoring, and builds confidence in releases. Use JUnit for unit tests, MockK/Mockito for mocking, and Espresso for UI tests. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "70% unit tests (fast, isolated), 20% integration tests (module interactions), 10% UI tests (end-to-end). Balance speed, reliability, and coverage."
  },
  {
    "id": 120,
    "level": "senior",
    "question": "What is ViewPager2 and its advantages over ViewPager?",
    "look_for": "Understanding of migration from ViewPager, DiffUtil usage, and handling of nested scrolling.",
    "answer": "ViewPager2 uses **RecyclerView** internally, supports vertical scrolling, RTL layout, and notifyDataSetChanged properly. More flexible and performant. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "ViewPager2 uses RecyclerView internally, supports vertical scrolling, RTL layout, and notifyDataSetChanged properly. More flexible and performant."
  },
  {
    "id": 121,
    "level": "senior",
    "question": "Explain the concept of single source of truth.",
    "look_for": "Understanding of Repository pattern, cache invalidation strategies, and conflict resolution.",
    "answer": "One authoritative data source (usually local database) that other parts of the app read from, ensuring consistency and simplifying data flow. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "One authoritative data source (usually local database) that other parts of the app read from, ensuring consistency and simplifying data flow."
  },
  {
    "id": 122,
    "level": "senior",
    "question": "What is Kotlin Multiplatform Mobile (KMM)?",
    "look_for": "Understanding of expect/actual mechanism, experience with shared module setup, awareness of limitations.",
    "answer": "KMM allows sharing code between Android and iOS, particularly business logic, while keeping platform-specific UI code separate. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "KMM allows sharing code between Android and iOS, particularly business logic, while keeping platform-specific UI code separate."
  },
  {
    "id": 123,
    "level": "senior",
    "question": "How do you optimize RecyclerView performance?",
    "look_for": "Deep understanding of RecyclerView internals, measurement, layout, and scrolling performance optimization.",
    "answer": "Use DiffUtil, set fixed size, implement ViewHolder properly, avoid expensive operations in onBind, use RecycledViewPool for nested RecyclerViews, implement pagination. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks.",
    "short_answer": "Use DiffUtil, set fixed size, implement ViewHolder properly, avoid expensive operations in onBind, use RecycledViewPool for nested RecyclerViews, implement pagination."
  },
  {
    "id": 124,
    "level": "senior",
    "question": "Explain Android's scoped storage.",
    "look_for": "Understanding of migration strategies, handling legacy storage, knowledge of MANAGE_EXTERNAL_STORAGE permission implications.",
    "answer": "Scoped storage restricts app access to external storage, requiring MediaStore API for media files and Storage Access Framework for documents. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Scoped storage restricts app access to external storage, requiring MediaStore API for media files and Storage Access Framework for documents."
  },
  {
    "id": 125,
    "level": "senior",
    "question": "What is the difference between Dispatchers.IO and Dispatchers.Default?",
    "look_for": "Understanding of thread pool sizing, when to use each, and custom dispatcher creation.",
    "answer": "Dispatchers.IO has shared thread pool (64 threads) optimized for blocking operations. Dispatchers.Default has limited threads (CPU cores) for CPU-intensive work. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Dispatchers.IO has shared thread pool (64 threads) optimized for blocking operations. Dispatchers.Default has limited threads (CPU cores) for CPU-intensive work."
  },
  {
    "id": 126,
    "level": "senior",
    "question": "How do you implement a custom View?",
    "look_for": "Understanding of measurement specs, canvas drawing, touch event handling, and performance considerations.",
    "answer": "Extend View or ViewGroup, override onMeasure, onLayout (ViewGroup), onDraw, handle touch events, manage state, and provide custom attributes. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "Extend View or ViewGroup, override onMeasure, onLayout (ViewGroup), onDraw, handle touch events, manage state, and provide custom attributes."
  },
  {
    "id": 127,
    "level": "senior",
    "question": "Explain Android's window and surface management.",
    "look_for": "Understanding of surface lifecycle, double buffering, hardware acceleration, and when to use SurfaceView vs TextureView.",
    "answer": "Window contains View hierarchy, Surface is drawing buffer. SurfaceView for separate rendering thread, TextureView for transformation, SurfaceFlinger composites surfaces. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Window contains View hierarchy, Surface is drawing buffer. SurfaceView for separate rendering thread, TextureView for transformation, SurfaceFlinger composites surfaces."
  },
  {
    "id": 128,
    "level": "senior",
    "question": "What is flow operators and their categories?",
    "look_for": "Understanding of cold flow nature, operator chaining, context preservation, and performance considerations.",
    "answer": "Terminal operators (collect, toList), intermediate operators (map, filter, transform), and flow builders (flow, channelFlow). Transform flow emissions without collecting. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Terminal operators (collect, toList), intermediate operators (map, filter, transform), and flow builders (flow, channelFlow). Transform flow emissions without collecting."
  },
  {
    "id": 129,
    "level": "senior",
    "question": "How do you handle configuration changes efficiently?",
    "look_for": "Deep understanding of configuration change impact, when to handle vs prevent, and testing strategies.",
    "answer": "Use **ViewModel** for UI state, handle orientation in manifest if needed, use fragments carefully, implement proper state saving, consider **ViewModel** with SavedStateHandle. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks.",
    "short_answer": "Use ViewModel for UI state, handle orientation in manifest if needed, use fragments carefully, implement proper state saving, consider ViewModel with SavedStateHandle."
  },
  {
    "id": 130,
    "level": "senior",
    "question": "Explain Android's backup and restore mechanisms.",
    "look_for": "Understanding of backup rules XML, include/exclude patterns, and restore testing.",
    "answer": "Auto Backup (API 23+) for files, Key/Value Backup for small data. BackupAgent for custom backup logic. Configure in manifest and test thoroughly. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Auto Backup (API 23+) for files, Key/Value Backup for small data. BackupAgent for custom backup logic. Configure in manifest and test thoroughly."
  },
  {
    "id": 131,
    "level": "senior",
    "question": "What is the difference between suspendCoroutine and suspendCancellableCoroutine?",
    "look_for": "Understanding of cancellation handling, proper resource cleanup, and integration with non-coroutine APIs.",
    "answer": "suspendCancellableCoroutine supports cancellation handling, allowing cleanup when coroutine is cancelled. Use for wrapping callback-based APIs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "suspendCancellableCoroutine supports cancellation handling, allowing cleanup when coroutine is cancelled. Use for wrapping callback-based APIs."
  },
  {
    "id": 132,
    "level": "senior",
    "question": "How do you implement real-time data synchronization?",
    "look_for": "Experience with real-time protocols, understanding of consistency models, and conflict resolution strategies.",
    "answer": "Use WebSocket or Firebase Realtime **Database**, implement conflict resolution (last-write-wins, operational transformation), handle connection state, queue offline changes. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use WebSocket or Firebase Realtime Database, implement conflict resolution (last-write-wins, operational transformation), handle connection state, queue offline changes."
  },
  {
    "id": 133,
    "level": "senior",
    "question": "Explain Android's process lifecycle and priority.",
    "look_for": "Understanding of process management, how to increase priority, and handling process death.",
    "answer": "Foreground (visible activity), Visible (visible but not foreground), **Service** (started service), Background (stopped activity), Empty (no components). System kills lowest priority first. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Foreground (visible activity), Visible (visible but not foreground), Service (started service), Background (stopped activity), Empty (no components). System kills lowest priority first."
  },
  {
    "id": 134,
    "level": "senior",
    "question": "What is Kotlin's inline functions and when to use them?",
    "look_for": "Understanding of performance benefits, code size trade-offs, reified type parameters, and non-local returns.",
    "answer": "Inline functions replace function call with function body at compile time, avoiding object allocation for lambdas. Use for higher-order functions. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Inline functions replace function call with function body at compile time, avoiding object allocation for lambdas. Use for higher-order functions."
  },
  {
    "id": 135,
    "level": "senior",
    "question": "How do you implement proper error handling in coroutines?",
    "look_for": "Understanding of exception propagation, structured concurrency implications, and error handling patterns.",
    "answer": "Use try-catch in coroutine body, CoroutineExceptionHandler for uncaught exceptions, SupervisorJob to prevent exception propagation to siblings. Proper implementation requires understanding the underlying mechanisms and following Android best practices. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Use try-catch in coroutine body, CoroutineExceptionHandler for uncaught exceptions, SupervisorJob to prevent exception propagation to siblings."
  },
  {
    "id": 136,
    "level": "senior",
    "question": "Explain Android's animation framework.",
    "look_for": "Understanding of different animation types, interpolators, AnimatorSet, and performance optimization.",
    "answer": "Property Animation (ObjectAnimator, ValueAnimator), View Animation (deprecated), Transition API for scene changes, MotionLayout for complex animations. Since this approach is deprecated, modern Android development uses alternatives like Kotlin Coroutines, Flow, or WorkManager, which provide better lifecycle awareness, error handling, and performance. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Property Animation (ObjectAnimator, ValueAnimator), View Animation (deprecated), Transition API for scene changes, MotionLayout for complex animations."
  },
  {
    "id": 137,
    "level": "senior",
    "question": "What is the difference between Room's @Dao suspend functions and Flow?",
    "look_for": "Understanding of reactive database queries, when to use each approach, and performance implications.",
    "answer": "Suspend functions execute once and return result. **Flow** observes database changes and emits new data automatically when table updates. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Suspend functions execute once and return result. Flow observes database changes and emits new data automatically when table updates."
  },
  {
    "id": 138,
    "level": "senior",
    "question": "How do you implement app modularization strategy?",
    "look_for": "Experience with module structure design, understanding of build performance impact, and dependency management.",
    "answer": "Separate features into modules, define clear dependencies (feature modules depend on core/data), use dependency injection, implement navigation boundaries. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Separate features into modules, define clear dependencies (feature modules depend on core/data), use dependency injection, implement navigation boundaries."
  },
  {
    "id": 139,
    "level": "senior",
    "question": "Explain Android's WorkManager constraints and execution.",
    "look_for": "Deep understanding of work types (OneTime, Periodic), execution guarantees, and migration from JobScheduler.",
    "answer": "**WorkManager** supports constraints (network, battery, storage), guarantees execution, survives process death, handles backoff policies, supports chaining. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "WorkManager supports constraints (network, battery, storage), guarantees execution, survives process death, handles backoff policies, supports chaining."
  },
  {
    "id": 140,
    "level": "senior",
    "question": "What is SharedFlow's replay cache and buffer?",
    "look_for": "Understanding of buffer strategies (suspend, drop oldest/latest), replay behavior, and memory implications.",
    "answer": "Replay cache stores emissions for new subscribers. Buffer stores emissions when no subscribers or slow subscribers, configurable with overflow strategies. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Replay cache stores emissions for new subscribers. Buffer stores emissions when no subscribers or slow subscribers, configurable with overflow strategies."
  },
  {
    "id": 141,
    "level": "senior",
    "question": "How do you implement deep linking navigation with Navigation Component?",
    "look_for": "Experience with nested graphs, argument passing, and handling edge cases like authenticated screens.",
    "answer": "Define nav_graph with deepLink tags, add intent-filter in manifest, handle arguments with SafeArgs, implement PendingIntent for notifications. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Define nav_graph with deepLink tags, add intent-filter in manifest, handle arguments with SafeArgs, implement PendingIntent for notifications."
  },
  {
    "id": 142,
    "level": "senior",
    "question": "Explain Compose's side effects (LaunchedEffect, DisposableEffect, etc.).",
    "look_for": "Understanding of when to use each, avoiding infinite recomposition, and proper key management.",
    "answer": "LaunchedEffect for **suspend** functions, DisposableEffect for cleanup, SideEffect for non-compose state, derivedStateOf for computed state, snapshotFlow for **Flow** conversion. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "LaunchedEffect for suspend functions, DisposableEffect for cleanup, SideEffect for non-compose state, derivedStateOf for computed state, snapshotFlow for Flow conversion."
  },
  {
    "id": 143,
    "level": "senior",
    "question": "What is Android's memory management and garbage collection?",
    "look_for": "Understanding of GC impact on performance, memory profiling, and leak detection techniques.",
    "answer": "ART uses generational garbage collection (young, old generations), compacting GC to reduce fragmentation. Apps have limited heap size based on device. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "ART uses generational garbage collection (young, old generations), compacting GC to reduce fragmentation. Apps have limited heap size based on device."
  },
  {
    "id": 144,
    "level": "senior",
    "question": "How do you implement effective caching strategy?",
    "look_for": "Understanding of cache coherency, invalidation strategies, and appropriate cache sizes.",
    "answer": "Multi-layer caching: memory (LruCache), disk (**Room**, DataStore), network. Implement cache invalidation, expiration policies, and cache-aside pattern. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Multi-layer caching: memory (LruCache), disk (Room, DataStore), network. Implement cache invalidation, expiration policies, and cache-aside pattern."
  },
  {
    "id": 145,
    "level": "senior",
    "question": "Explain Android's Input Method Framework.",
    "look_for": "Understanding of keyboard visibility handling, IME actions, and custom input handling.",
    "answer": "IMF manages soft keyboard interaction, handles input connection, provides InputMethodManager API. Custom views implement InputConnection for complex input. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "IMF manages soft keyboard interaction, handles input connection, provides InputMethodManager API. Custom views implement InputConnection for complex input."
  },
  {
    "id": 146,
    "level": "senior",
    "question": "What is Kotlin's delegation pattern and property delegates?",
    "look_for": "Understanding of lazy, observable delegates, and creating custom delegates.",
    "answer": "Class delegation (by keyword) delegates interface implementation. Property delegates (by keyword) delegate property accessors to another object. This is a fundamental concept in Android development that developers should understand for building robust applications. This pattern promotes separation of concerns, improves testability, enhances code maintainability, and makes the codebase more scalable and easier to understand.",
    "short_answer": "Class delegation (by keyword) delegates interface implementation. Property delegates (by keyword) delegate property accessors to another object."
  },
  {
    "id": 147,
    "level": "senior",
    "question": "How do you optimize app startup time?",
    "look_for": "Experience with startup profiling, understanding of critical path, and measurement techniques.",
    "answer": "Lazy initialization, avoid work in **Application**.onCreate, use App Startup library, optimize dependencies, implement splash screen properly, profile with Perfetto. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks.",
    "short_answer": "Lazy initialization, avoid work in Application.onCreate, use App Startup library, optimize dependencies, implement splash screen properly, profile with Perfetto."
  },
  {
    "id": 148,
    "level": "senior",
    "question": "Explain Android's notification channels and importance.",
    "look_for": "Understanding of channel management, notification best practices, and user control considerations.",
    "answer": "Channels (API 26+) let users control notification behavior per category. Importance determines interruption level: urgent, high, default, low, min. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Channels (API 26+) let users control notification behavior per category. Importance determines interruption level: urgent, high, default, low, min."
  },
  {
    "id": 149,
    "level": "senior",
    "question": "What is Kotlin's coroutine context and its elements?",
    "look_for": "Understanding of context inheritance, combination with plus operator, and withContext usage.",
    "answer": "CoroutineContext is a set of elements: **Job** (lifecycle), **Dispatcher** (thread), CoroutineName (debugging), CoroutineExceptionHandler (errors). Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "CoroutineContext is a set of elements: Job (lifecycle), Dispatcher (thread), CoroutineName (debugging), CoroutineExceptionHandler (errors)."
  },
  {
    "id": 150,
    "level": "senior",
    "question": "How do you implement proper logging strategy?",
    "look_for": "Understanding of logging best practices, security implications, and integration with monitoring tools.",
    "answer": "Use Timber for structured logging, remove logs in release builds with **ProGuard**, implement crash reporting (Firebase Crashlytics), log appropriate levels. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use Timber for structured logging, remove logs in release builds with ProGuard, implement crash reporting (Firebase Crashlytics), log appropriate levels."
  },
  {
    "id": 151,
    "level": "senior",
    "question": "Explain Android's JobIntentService and when to use it.",
    "look_for": "Understanding of migration path to WorkManager and backwards compatibility considerations.",
    "answer": "JobIntentService is a bridge between IntentService and JobScheduler, handling work on background thread. Now deprecated in favor of **WorkManager**. Since this approach is deprecated, modern Android development uses alternatives like Kotlin Coroutines, Flow, or WorkManager, which provide better lifecycle awareness, error handling, and performance. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "JobIntentService is a bridge between IntentService and JobScheduler, handling work on background thread. Now deprecated in favor of WorkManager."
  },
  {
    "id": 152,
    "level": "senior",
    "question": "What is Compose's remember and rememberSaveable?",
    "look_for": "Understanding of state preservation, custom Saver implementation, and memory implications.",
    "answer": "remember stores value across recompositions. rememberSaveable survives configuration changes and process death by saving to **Bundle**. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "remember stores value across recompositions. rememberSaveable survives configuration changes and process death by saving to Bundle."
  },
  {
    "id": 153,
    "level": "senior",
    "question": "How do you implement efficient bitmap loading and caching?",
    "look_for": "Understanding of bitmap memory usage, sampling, and hardware vs software bitmaps.",
    "answer": "Calculate inSampleSize, decode bounds first, use RGB_565 when possible, implement LruCache, handle OutOfMemory gracefully, use libraries like **Glide**/Coil. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks.",
    "short_answer": "Calculate inSampleSize, decode bounds first, use RGB_565 when possible, implement LruCache, handle OutOfMemory gracefully, use libraries like Glide/Coil."
  },
  {
    "id": 154,
    "level": "senior",
    "question": "Explain Android's App Bundle and Dynamic Feature Modules.",
    "look_for": "Experience with bundle generation, understanding of split APKs, and implementing dynamic feature navigation.",
    "answer": "App **Bundle** optimizes APK delivery per device config. Dynamic Features are downloaded on-demand, reducing initial install size, supporting conditional/on-demand delivery. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "App Bundle optimizes APK delivery per device config. Dynamic Features are downloaded on-demand, reducing initial install size, supporting conditional/on-demand delivery."
  },
  {
    "id": 155,
    "level": "senior",
    "question": "What is Kotlin's reified type parameters?",
    "look_for": "Understanding of inline function requirement, use cases like generic type checking, and limitations.",
    "answer": "Reified allows accessing type information at runtime in **inline** functions, enabling operations like is checks and getting class references. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Reified allows accessing type information at runtime in inline functions, enabling operations like is checks and getting class references."
  },
  {
    "id": 156,
    "level": "senior",
    "question": "How do you implement proper database migrations in Room?",
    "look_for": "Experience with migration testing, understanding of destructive vs non-destructive migrations, and fallback strategies.",
    "answer": "Define **Migration** objects specifying version range and SQL statements, add to database builder, test migrations, handle complex schema changes. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Define Migration objects specifying version range and SQL statements, add to database builder, test migrations, handle complex schema changes."
  },
  {
    "id": 157,
    "level": "senior",
    "question": "Explain Android's StrictMode and its usage.",
    "look_for": "Understanding of policies (thread, VM), penalty configuration, and integration in development workflow.",
    "answer": "StrictMode detects disk reads/writes, network operations on main thread, and other violations. Use in debug builds to catch performance issues early. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "StrictMode detects disk reads/writes, network operations on main thread, and other violations. Use in debug builds to catch performance issues early."
  },
  {
    "id": 158,
    "level": "senior",
    "question": "What is the difference between produceIn and channelFlow?",
    "look_for": "Understanding of when to use channels vs Flow, and callback-to-Flow conversion patterns.",
    "answer": "produceIn creates a channel from a coroutine scope. channelFlow creates a cold **Flow** that uses a channel internally, better for **Flow** operators. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "produceIn creates a channel from a coroutine scope. channelFlow creates a cold Flow that uses a channel internally, better for Flow operators."
  },
  {
    "id": 159,
    "level": "senior",
    "question": "How do you implement A/B testing in Android?",
    "look_for": "Experience with experimentation platforms, understanding of statistical significance, and implementation patterns.",
    "answer": "Use Firebase Remote Config or similar service, implement feature flags, track analytics, ensure proper randomization and consistent user experience. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Effective testing ensures code quality, prevents regressions, facilitates refactoring, and builds confidence in releases. Use JUnit for unit tests, MockK/Mockito for mocking, and Espresso for UI tests.",
    "short_answer": "Use Firebase Remote Config or similar service, implement feature flags, track analytics, ensure proper randomization and consistent user experience."
  },
  {
    "id": 160,
    "level": "senior",
    "question": "Explain Android's Accessibility framework.",
    "look_for": "Understanding of AccessibilityNodeInfo, custom View accessibility, and WCAG guidelines.",
    "answer": "Provide contentDescription, use semantic markup, support TalkBack, ensure touch target sizes (48dp), maintain proper focus order, test with accessibility services. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Provide contentDescription, use semantic markup, support TalkBack, ensure touch target sizes (48dp), maintain proper focus order, test with accessibility services."
  },
  {
    "id": 161,
    "level": "senior",
    "question": "What is Kotlin's contravariance and covariance?",
    "look_for": "Deep understanding of variance, use-site vs declaration-site variance, and practical applications.",
    "answer": "Covariance (out) allows reading but not writing (producer). Contravariance (in) allows writing but not reading (consumer). PECS principle. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Covariance (out) allows reading but not writing (producer). Contravariance (in) allows writing but not reading (consumer). PECS principle."
  },
  {
    "id": 162,
    "level": "senior",
    "question": "How do you implement proper WebView security?",
    "look_for": "Understanding of XSS attacks, JavaScript bridge security, and WebView configuration best practices.",
    "answer": "Validate URLs, disable JavaScript if not needed, implement shouldOverrideUrlLoading, avoid addJavascriptInterface, use HTTPS, keep WebView updated. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Security is paramount in mobile development - always follow the principle of least privilege, validate inputs, encrypt sensitive data, and keep security libraries updated to protect user privacy and data.",
    "short_answer": "Validate URLs, disable JavaScript if not needed, implement shouldOverrideUrlLoading, avoid addJavascriptInterface, use HTTPS, keep WebView updated."
  },
  {
    "id": 163,
    "level": "senior",
    "question": "Explain Android's Content Provider security.",
    "look_for": "Understanding of security implications, proper permission configuration, and query validation.",
    "answer": "Use permissions (readPermission, writePermission), implement path permissions, validate URIs, sanitize inputs, avoid SQL injection. Security is paramount in mobile development - always follow the principle of least privilege, validate inputs, encrypt sensitive data, and keep security libraries updated to protect user privacy and data. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Use permissions (readPermission, writePermission), implement path permissions, validate URIs, sanitize inputs, avoid SQL injection."
  },
  {
    "id": 164,
    "level": "senior",
    "question": "What is DataStore and how does it differ from SharedPreferences?",
    "look_for": "Understanding of Preferences DataStore vs Proto DataStore, migration from SharedPreferences, and error handling.",
    "answer": "DataStore is type-safe (Proto DataStore) or uses **Flow**, handles exceptions properly, supports migrations, and provides consistency guarantees. Built on coroutines. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "DataStore is type-safe (Proto DataStore) or uses Flow, handles exceptions properly, supports migrations, and provides consistency guarantees. Built on coroutines."
  },
  {
    "id": 165,
    "level": "senior",
    "question": "How do you implement proper network layer architecture?",
    "look_for": "Experience with Retrofit configuration, OkHttp customization, and error handling patterns.",
    "answer": "Separate API service, data models, and mappers. Implement retry logic, timeout configuration, error handling, certificate pinning, request/response interceptors. Proper implementation requires understanding the underlying mechanisms and following Android best practices. In production environments, monitor this aspect closely, use analytics to measure impact, and iterate based on real-world usage patterns.",
    "short_answer": "Separate API service, data models, and mappers. Implement retry logic, timeout configuration, error handling, certificate pinning, request/response interceptors."
  },
  {
    "id": 166,
    "level": "senior",
    "question": "Explain Android's Canvas and custom drawing.",
    "look_for": "Understanding of coordinate systems, Paint styles, hardware acceleration limitations, and performance optimization.",
    "answer": "Canvas provides drawing API (drawRect, drawPath, etc.). Paint defines style. Path defines shapes. Use for custom views, charts, complex graphics. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Canvas provides drawing API (drawRect, drawPath, etc.). Paint defines style. Path defines shapes. Use for custom views, charts, complex graphics."
  },
  {
    "id": 167,
    "level": "senior",
    "question": "What is Kotlin's inline classes (value classes)?",
    "look_for": "Understanding of use cases, boxing scenarios, and restrictions on value classes.",
    "answer": "Value classes wrap a single value without allocation overhead at runtime, providing type safety without performance cost. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Value classes wrap a single value without allocation overhead at runtime, providing type safety without performance cost."
  },
  {
    "id": 168,
    "level": "senior",
    "question": "How do you implement proper error handling in Repository pattern?",
    "look_for": "Understanding of error propagation, user-facing error messages, and recovery strategies.",
    "answer": "Use **sealed** classes for Result/State, wrap network/database exceptions, provide meaningful error messages, implement retry logic, log errors appropriately. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use sealed classes for Result/State, wrap network/database exceptions, provide meaningful error messages, implement retry logic, log errors appropriately."
  },
  {
    "id": 169,
    "level": "senior",
    "question": "Explain Android's PendingIntent flags and their importance.",
    "look_for": "Understanding of security implications, Android 12 requirements, and appropriate flag usage.",
    "answer": "FLAG_IMMUTABLE (recommended, Android 12+), FLAG_MUTABLE (explicit mutability), FLAG_UPDATE_CURRENT, FLAG_ONE_SHOT, FLAG_CANCEL_CURRENT affect intent behavior and security. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "FLAG_IMMUTABLE (recommended, Android 12+), FLAG_MUTABLE (explicit mutability), FLAG_UPDATE_CURRENT, FLAG_ONE_SHOT, FLAG_CANCEL_CURRENT affect intent behavior and security."
  },
  {
    "id": 170,
    "level": "senior",
    "question": "What is Compose's derivedStateOf and when to use it?",
    "look_for": "Understanding of recomposition optimization, comparison with remember, and appropriate use cases.",
    "answer": "derivedStateOf creates computed state that only recomposes when result changes, not when inputs change, optimizing expensive calculations. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "derivedStateOf creates computed state that only recomposes when result changes, not when inputs change, optimizing expensive calculations."
  },
  {
    "id": 171,
    "level": "senior",
    "question": "How do you implement proper analytics architecture?",
    "look_for": "Understanding of analytics best practices, event taxonomy, and GDPR compliance considerations.",
    "answer": "**Abstract** analytics behind interface, support multiple providers, track events consistently, implement privacy controls, test analytics in debug builds. Proper implementation requires understanding the underlying mechanisms and following Android best practices. In production environments, monitor this aspect closely, use analytics to measure impact, and iterate based on real-world usage patterns.",
    "short_answer": "Abstract analytics behind interface, support multiple providers, track events consistently, implement privacy controls, test analytics in debug builds."
  },
  {
    "id": 172,
    "level": "senior",
    "question": "Explain Android's MediaPlayer vs ExoPlayer.",
    "look_for": "Understanding of use cases, format support, and migration to Media3.",
    "answer": "MediaPlayer is basic, built-in player. ExoPlayer is flexible, supports more formats, adaptive streaming, DRM, extensible, and regularly updated. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "MediaPlayer is basic, built-in player. ExoPlayer is flexible, supports more formats, adaptive streaming, DRM, extensible, and regularly updated."
  },
  {
    "id": 173,
    "level": "senior",
    "question": "What is Kotlin's Nothing type?",
    "look_for": "Understanding of type system implications, use in throw expressions, and nullable Nothing?.",
    "answer": "Nothing is a type with no instances, representing functions that never return normally (always throw or infinite loop). Subtype of all types. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Nothing is a type with no instances, representing functions that never return normally (always throw or infinite loop). Subtype of all types."
  },
  {
    "id": 174,
    "level": "senior",
    "question": "How do you implement proper pagination with Paging 3?",
    "look_for": "Understanding of RemoteMediator for offline support, error handling, and retry mechanisms.",
    "answer": "Implement PagingSource, define RemoteMediator for network+database, configure PagingConfig, collect PagingData in **ViewModel**, submit to PagingDataAdapter. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Implement PagingSource, define RemoteMediator for network+database, configure PagingConfig, collect PagingData in ViewModel, submit to PagingDataAdapter."
  },
  {
    "id": 175,
    "level": "senior",
    "question": "Explain Android's Foreground Services and notification requirements.",
    "look_for": "Understanding of foreground service types (Android 11+), restrictions, and proper lifecycle management.",
    "answer": "Foreground services require persistent notification (Android 8+), must call startForeground within 5 seconds, need FOREGROUND_SERVICE permission, subject to restrictions. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Foreground services require persistent notification (Android 8+), must call startForeground within 5 seconds, need FOREGROUND_SERVICE permission, subject to restrictions."
  },
  {
    "id": 176,
    "level": "senior",
    "question": "What is the difference between callbackFlow and channelFlow?",
    "look_for": "Understanding of awaitClose importance, ProducerScope vs SendChannel, and cancellation handling.",
    "answer": "Both create **Flow** from callback APIs. callbackFlow has explicit send channel control. channelFlow is simpler for most cases. Both are hot while collecting. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Both create Flow from callback APIs. callbackFlow has explicit send channel control. channelFlow is simpler for most cases. Both are hot while collecting."
  },
  {
    "id": 177,
    "level": "senior",
    "question": "How do you implement proper localization and internationalization?",
    "look_for": "Understanding of resource qualifiers, RTL support, and common localization pitfalls.",
    "answer": "Use string resources with qualifiers, support RTL layouts, format dates/numbers properly, handle plurals, test with pseudolocales, consider cultural differences. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use string resources with qualifiers, support RTL layouts, format dates/numbers properly, handle plurals, test with pseudolocales, consider cultural differences."
  },
  {
    "id": 178,
    "level": "senior",
    "question": "Explain Android's Network Security Configuration.",
    "look_for": "Understanding of certificate pinning implementation, cleartext traffic implications, and security best practices.",
    "answer": "XML file defining app's network security settings: trusted CAs, certificate pinning, cleartext traffic policy, debug overrides. Security is paramount in mobile development - always follow the principle of least privilege, validate inputs, encrypt sensitive data, and keep security libraries updated to protect user privacy and data. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "XML file defining app's network security settings: trusted CAs, certificate pinning, cleartext traffic policy, debug overrides."
  },
  {
    "id": 179,
    "level": "senior",
    "question": "What is Compose's produceState?",
    "look_for": "Understanding of state production patterns, lifecycle awareness, and comparison with LaunchedEffect + mutableStateOf.",
    "answer": "produceState launches a coroutine to produce a State value from **suspend** functions, bridging non-**Compose** state sources into Compose. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "produceState launches a coroutine to produce a State value from suspend functions, bridging non-Compose state sources into Compose."
  },
  {
    "id": 180,
    "level": "senior",
    "question": "How do you implement proper feature flagging?",
    "look_for": "Understanding of flag lifecycle, testing strategies, and integration with build variants.",
    "answer": "Use Remote Config or feature flag service, implement local overrides for testing, separate flag evaluation logic, support gradual rollouts and A/B testing. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use Remote Config or feature flag service, implement local overrides for testing, separate flag evaluation logic, support gradual rollouts and A/B testing."
  },
  {
    "id": 181,
    "level": "senior",
    "question": "Explain Android's Doze mode and App Standby.",
    "look_for": "Understanding of maintenance windows, exemption strategies, and testing with adb commands.",
    "answer": "Doze restricts network, wakelocks, and background work when device is idle. App Standby buckets affect job and alarm execution. Use high-priority FCM for urgent messages. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Doze restricts network, wakelocks, and background work when device is idle. App Standby buckets affect job and alarm execution. Use high-priority FCM for urgent messages."
  },
  {
    "id": 182,
    "level": "senior",
    "question": "What is Kotlin's @JvmOverloads annotation?",
    "look_for": "Understanding of Java interoperability, use cases, and constructor overloading.",
    "answer": "@JvmOverloads generates Java overloaded methods for default parameters, enabling Java interop with Kotlin default arguments. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "@JvmOverloads generates Java overloaded methods for default parameters, enabling Java interop with Kotlin default arguments."
  },
  {
    "id": 183,
    "level": "senior",
    "question": "How do you implement proper dependency management with version catalogs?",
    "look_for": "Understanding of TOML structure, migration from buildSrc, and convention plugins.",
    "answer": "**Define** dependencies in libs.versions.toml, use type-safe accessors, centralize version management, support version ranges and rich versions. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Define dependencies in libs.versions.toml, use type-safe accessors, centralize version management, support version ranges and rich versions."
  },
  {
    "id": 184,
    "level": "senior",
    "question": "Explain Android's Background Execution Limits.",
    "look_for": "Understanding of restrictions across Android versions, appropriate alternatives, and migration strategies.",
    "answer": "Android limits background services (O+), location updates (O+), broadcast receivers (O+). Use **WorkManager**, JobScheduler, or foreground services appropriately. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Android limits background services (O+), location updates (O+), broadcast receivers (O+). Use WorkManager, JobScheduler, or foreground services appropriately."
  },
  {
    "id": 185,
    "level": "senior",
    "question": "What is Compose's snapshotFlow?",
    "look_for": "Understanding of Snapshot system, use cases for bridging Compose state to Flow consumers.",
    "answer": "snapshotFlow converts **Compose** State reads into a **Flow**, emitting when any read State changes. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "snapshotFlow converts Compose State reads into a Flow, emitting when any read State changes."
  },
  {
    "id": 186,
    "level": "senior",
    "question": "How do you implement proper crash reporting and monitoring?",
    "look_for": "Understanding of symbolication, ProGuard mapping files, and crash analysis techniques.",
    "answer": "Integrate Firebase Crashlytics or Sentry, log custom events, add breadcrumbs, implement custom exception handler, monitor ANRs, analyze trends. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Integrate Firebase Crashlytics or Sentry, log custom events, add breadcrumbs, implement custom exception handler, monitor ANRs, analyze trends."
  },
  {
    "id": 187,
    "level": "senior",
    "question": "Explain Android's Slices.",
    "look_for": "Understanding of Slice providers, templates, and use cases for surfacing app content.",
    "answer": "Slices are UI templates that display app content in other apps (Google Search, Assistant). Define templates for interactive content outside your app. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Slices are UI templates that display app content in other apps (Google Search, Assistant). Define templates for interactive content outside your app."
  },
  {
    "id": 188,
    "level": "senior",
    "question": "What is the difference between @Inject constructor and @Provides?",
    "look_for": "Understanding of Hilt/Dagger dependency provision strategies and when to use each.",
    "answer": "@Inject constructor for types you own. @Provides in modules for third-party classes, interfaces, or complex construction logic. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "@Inject constructor for types you own. @Provides in modules for third-party classes, interfaces, or complex construction logic."
  },
  {
    "id": 189,
    "level": "senior",
    "question": "How do you implement proper image pipeline optimization?",
    "look_for": "Understanding of image formats, caching strategies, and performance monitoring.",
    "answer": "Use appropriate formats (WebP, AVIF), implement progressive loading, **lazy** load images, use placeholder strategies, implement disk/memory caching, resize on server. Proper implementation requires understanding the underlying mechanisms and following Android best practices. In production environments, monitor this aspect closely, use analytics to measure impact, and iterate based on real-world usage patterns.",
    "short_answer": "Use appropriate formats (WebP, AVIF), implement progressive loading, lazy load images, use placeholder strategies, implement disk/memory caching, resize on server."
  },
  {
    "id": 190,
    "level": "senior",
    "question": "Explain Android's ProfileInstaller and baseline profiles.",
    "look_for": "Understanding of profile generation, ART compilation tiers, and performance impact measurement.",
    "answer": "Baseline profiles define critical code paths for AOT compilation, improving startup time. ProfileInstaller ships profiles with app or installs them post-launch. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Baseline profiles define critical code paths for AOT compilation, improving startup time. ProfileInstaller ships profiles with app or installs them post-launch."
  },
  {
    "id": 191,
    "level": "senior",
    "question": "What is Kotlin's @Parcelize custom serializer?",
    "look_for": "Understanding of custom serialization needs and TypeParceler annotation.",
    "answer": "Implement Parceler<T> interface to customize how specific properties are written to/read from Parcel, handling complex types. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Implement Parceler<T> interface to customize how specific properties are written to/read from Parcel, handling complex types."
  },
  {
    "id": 192,
    "level": "senior",
    "question": "How do you implement proper date/time handling?",
    "look_for": "Understanding of timezone pitfalls, LocalDateTime vs Instant, and backwards compatibility.",
    "answer": "**Use** java.time (API 26+) with desugaring, store timestamps in UTC, format using appropriate locales, handle timezone conversions carefully. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use java.time (API 26+) with desugaring, store timestamps in UTC, format using appropriate locales, handle timezone conversions carefully."
  },
  {
    "id": 193,
    "level": "senior",
    "question": "Explain Android's Package Visibility changes (Android 11+).",
    "look_for": "Understanding of privacy implications, query tag usage, and migration strategies.",
    "answer": "Apps can't see all installed packages by default. Declare queries in manifest or use QUERY_ALL_PACKAGES permission for specific use cases. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Apps can't see all installed packages by default. Declare queries in manifest or use QUERY_ALL_PACKAGES permission for specific use cases."
  },
  {
    "id": 194,
    "level": "senior",
    "question": "What is Compose's CompositionLocalProvider usage?",
    "look_for": "Understanding of scope, appropriate use cases, and alternatives like passing parameters explicitly.",
    "answer": "CompositionLocalProvider sets values for CompositionLocals within a specific composition scope, providing implicit dependencies to child composables. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "CompositionLocalProvider sets values for CompositionLocals within a specific composition scope, providing implicit dependencies to child composables."
  },
  {
    "id": 195,
    "level": "senior",
    "question": "How do you implement proper build variant configuration?",
    "look_for": "Understanding of flavor dimensions, variant-specific resources, and build configuration strategies.",
    "answer": "Use productFlavors for different versions, buildTypes for debug/release, configure signing, **ProGuard** rules, dependencies per variant, implement flavor-specific code. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "Use productFlavors for different versions, buildTypes for debug/release, configure signing, ProGuard rules, dependencies per variant, implement flavor-specific code."
  },
  {
    "id": 196,
    "level": "senior",
    "question": "Explain Android's Bubbles API.",
    "look_for": "Understanding of implementation requirements, use cases for conversational interfaces.",
    "answer": "Bubbles display conversations and tasks in floating windows. Require notification channel, proper metadata, and conversation shortcuts. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Bubbles display conversations and tasks in floating windows. Require notification channel, proper metadata, and conversation shortcuts."
  },
  {
    "id": 197,
    "level": "senior",
    "question": "What is the difference between distinctUntilChanged and distinctUntilChangedBy in Flow?",
    "look_for": "Understanding of use cases, performance implications, and custom comparators.",
    "answer": "distinctUntilChanged compares entire emission using equals. distinctUntilChangedBy compares using a selector function result. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "distinctUntilChanged compares entire emission using equals. distinctUntilChangedBy compares using a selector function result."
  },
  {
    "id": 198,
    "level": "senior",
    "question": "How do you implement proper SQLite performance optimization?",
    "look_for": "Understanding of query optimization, index strategy, and Room performance best practices.",
    "answer": "Use indexes, transactions for batch operations, compiled statements, appropriate data types, PRAGMA optimization, avoid N+1 queries. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks. In production environments, monitor this aspect closely, use analytics to measure impact, and iterate based on real-world usage patterns.",
    "short_answer": "Use indexes, transactions for batch operations, compiled statements, appropriate data types, PRAGMA optimization, avoid N+1 queries."
  },
  {
    "id": 199,
    "level": "senior",
    "question": "Explain Android's ActivityResultContracts API.",
    "look_for": "Understanding of built-in contracts, custom contracts, and registerForActivityResult usage.",
    "answer": "ActivityResultContracts replace startActivityForResult, providing type-safe results, cleaner API, support for multiple requests, and testing benefits. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "ActivityResultContracts replace startActivityForResult, providing type-safe results, cleaner API, support for multiple requests, and testing benefits."
  },
  {
    "id": 200,
    "level": "senior",
    "question": "What is Kotlin's contracts API?",
    "look_for": "Understanding of contract declarations, use cases, and limitations.",
    "answer": "Contracts API allows functions to declare constraints to the compiler (like implies, returns), improving smart-casts and null-safety analysis. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Contracts API allows functions to declare constraints to the compiler (like implies, returns), improving smart-casts and null-safety analysis."
  },
  {
    "id": 201,
    "level": "senior",
    "question": "How do you implement proper memory leak detection?",
    "look_for": "Understanding of common leak patterns, profiling techniques, and prevention strategies.",
    "answer": "Use LeakCanary, implement weak references where appropriate, avoid static references to **Context**, properly unregister listeners, test configuration changes. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks.",
    "short_answer": "Use LeakCanary, implement weak references where appropriate, avoid static references to Context, properly unregister listeners, test configuration changes."
  },
  {
    "id": 202,
    "level": "senior",
    "question": "Explain Android's App Shortcuts.",
    "look_for": "Understanding of shortcut types, icon handling, and integration with launcher.",
    "answer": "Static shortcuts in XML, dynamic shortcuts via ShortcutManager, pinned shortcuts on launcher. Support deep links for quick actions. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Static shortcuts in XML, dynamic shortcuts via ShortcutManager, pinned shortcuts on launcher. Support deep links for quick actions."
  },
  {
    "id": 203,
    "level": "senior",
    "question": "What is Compose's key composable function?",
    "look_for": "Understanding of when keys are needed, especially in lists, and stable vs unstable keys.",
    "answer": "key() helps **Compose** identify composable instances across recompositions, maintaining state and avoiding unwanted recomposition. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "key() helps Compose identify composable instances across recompositions, maintaining state and avoiding unwanted recomposition."
  },
  {
    "id": 204,
    "level": "senior",
    "question": "How do you implement proper code coverage for tests?",
    "look_for": "Understanding of coverage types, configuration, and interpretation of results.",
    "answer": "Use JaCoCo for coverage reporting, configure **Gradle**, set coverage thresholds, integrate with CI, focus on meaningful coverage over percentage. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Effective testing ensures code quality, prevents regressions, facilitates refactoring, and builds confidence in releases. Use JUnit for unit tests, MockK/Mockito for mocking, and Espresso for UI tests.",
    "short_answer": "Use JaCoCo for coverage reporting, configure Gradle, set coverage thresholds, integrate with CI, focus on meaningful coverage over percentage."
  },
  {
    "id": 205,
    "level": "senior",
    "question": "Explain Android's CameraX library.",
    "look_for": "Understanding of use cases, extensions, and migration from Camera2 API.",
    "answer": "CameraX simplifies camera development with use cases (Preview, ImageCapture, ImageAnalysis), lifecycle awareness, and device-specific fixes. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "CameraX simplifies camera development with use cases (Preview, ImageCapture, ImageAnalysis), lifecycle awareness, and device-specific fixes."
  },
  {
    "id": 206,
    "level": "senior",
    "question": "What is the difference between crossinline and noinline in Kotlin?",
    "look_for": "Understanding of inline function restrictions and appropriate use cases.",
    "answer": "crossinline prevents non-local returns in lambdas. noinline prevents inlining specific lambda parameters when others are inlined. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "crossinline prevents non-local returns in lambdas. noinline prevents inlining specific lambda parameters when others are inlined."
  },
  {
    "id": 207,
    "level": "senior",
    "question": "How do you implement proper color management and theming?",
    "look_for": "Understanding of theme attributes, DayNight themes, and Material Theming system.",
    "answer": "Use Material Design theming, support light/dark themes, implement dynamic colors (Material You), use semantic color tokens, test color contrast. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use Material Design theming, support light/dark themes, implement dynamic colors (Material You), use semantic color tokens, test color contrast."
  },
  {
    "id": 208,
    "level": "senior",
    "question": "Explain Android's Autofill Framework.",
    "look_for": "Understanding of autofill hints, save requests, and security considerations.",
    "answer": "Autofill Framework enables password managers to fill forms. Provide hints in XML, implement AutofillService for custom solutions. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Autofill Framework enables password managers to fill forms. Provide hints in XML, implement AutofillService for custom solutions."
  },
  {
    "id": 209,
    "level": "senior",
    "question": "What is Compose's AnimatedVisibility?",
    "look_for": "Understanding of enter/exit transitions, AnimatedContent difference, and animation specifications.",
    "answer": "AnimatedVisibility animates showing/hiding composables with enter/exit animations, supporting custom transitions and content animations. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "AnimatedVisibility animates showing/hiding composables with enter/exit animations, supporting custom transitions and content animations."
  },
  {
    "id": 210,
    "level": "senior",
    "question": "How do you implement proper ProGuard/R8 configuration?",
    "look_for": "Understanding of keep rules, optimization levels, and troubleshooting obfuscated crashes.",
    "answer": "Keep rules for reflection-based libraries, preserve line numbers for crashes, optimize appropriately, test release builds, maintain proguard-rules.pro. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Keep rules for reflection-based libraries, preserve line numbers for crashes, optimize appropriately, test release builds, maintain proguard-rules.pro."
  },
  {
    "id": 211,
    "level": "senior",
    "question": "Explain Android's WindowInsets and edge-to-edge display.",
    "look_for": "Understanding of WindowInsetsCompat, handling keyboard insets, and View.setOnApplyWindowInsetsListener.",
    "answer": "WindowInsets represent system UI (status bar, nav bar). Edge-to-edge draws under system bars, requiring proper insets handling for content. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "WindowInsets represent system UI (status bar, nav bar). Edge-to-edge draws under system bars, requiring proper insets handling for content."
  },
  {
    "id": 212,
    "level": "senior",
    "question": "What is Kotlin's @OptIn annotation?",
    "look_for": "Understanding of API evolution, RequiresOptIn annotation, and versioning implications.",
    "answer": "@OptIn allows using experimental or unstable APIs, requiring explicit opt-in, documenting that API might change. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "@OptIn allows using experimental or unstable APIs, requiring explicit opt-in, documenting that API might change."
  },
  {
    "id": 213,
    "level": "senior",
    "question": "How do you implement proper biometric authentication?",
    "look_for": "Understanding of BiometricManager, crypto operations, and fallback mechanisms.",
    "answer": "Use BiometricPrompt API, configure authenticator types (biometric, device credential), handle success/failure callbacks, implement crypto-based authentication. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use BiometricPrompt API, configure authenticator types (biometric, device credential), handle success/failure callbacks, implement crypto-based authentication."
  },
  {
    "id": 214,
    "level": "senior",
    "question": "Explain Android's Jetpack Benchmark library.",
    "look_for": "Understanding of benchmark setup, interpretation of results, and comparison strategies.",
    "answer": "Benchmark library measures code performance reliably, handles warmup, supports macrobenchmarks (UI) and microbenchmarks (code), outputs metrics. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Benchmark library measures code performance reliably, handles warmup, supports macrobenchmarks (UI) and microbenchmarks (code), outputs metrics."
  },
  {
    "id": 215,
    "level": "senior",
    "question": "What is Compose's SubcomposeLayout?",
    "look_for": "Understanding of advanced layout scenarios, performance implications, and comparison with regular Layout.",
    "answer": "SubcomposeLayout allows measuring children before composing them, enabling dynamic layouts based on child measurements. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "SubcomposeLayout allows measuring children before composing them, enabling dynamic layouts based on child measurements."
  },
  {
    "id": 216,
    "level": "senior",
    "question": "How do you implement proper APK size optimization?",
    "look_for": "Understanding of APK Analyzer usage, optimization techniques, and size impact measurement.",
    "answer": "Enable **R8**, use App **Bundle**, remove unused resources, compress images (WebP), use vector drawables, analyze APK, split by ABI/density. Proper implementation requires understanding the underlying mechanisms and following Android best practices. In production environments, monitor this aspect closely, use analytics to measure impact, and iterate based on real-world usage patterns.",
    "short_answer": "Enable R8, use App Bundle, remove unused resources, compress images (WebP), use vector drawables, analyze APK, split by ABI/density."
  },
  {
    "id": 217,
    "level": "senior",
    "question": "Explain Android's DownloadManager.",
    "look_for": "Understanding of download requests, notification handling, and proper cleanup.",
    "answer": "DownloadManager handles long-running HTTP downloads, survives app closure, provides notifications, supports query/control of downloads. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "DownloadManager handles long-running HTTP downloads, survives app closure, provides notifications, supports query/control of downloads."
  },
  {
    "id": 218,
    "level": "senior",
    "question": "What is the difference between Mutex and Semaphore in coroutines?",
    "look_for": "Understanding of mutual exclusion, use cases, and comparison with synchronized blocks.",
    "answer": "Mutex allows one coroutine to access resource at a time. Semaphore allows configurable number of concurrent accesses. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Mutex allows one coroutine to access resource at a time. Semaphore allows configurable number of concurrent accesses."
  },
  {
    "id": 219,
    "level": "senior",
    "question": "How do you implement proper clipboard handling?",
    "look_for": "Understanding of ClipData types, security implications of clipboard access.",
    "answer": "**Use** ClipboardManager, handle ClipData with MIME types, support rich content, implement copy/paste for custom views, consider privacy. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use ClipboardManager, handle ClipData with MIME types, support rich content, implement copy/paste for custom views, consider privacy."
  },
  {
    "id": 220,
    "level": "senior",
    "question": "Explain Android's Picture-in-Picture mode.",
    "look_for": "Understanding of PiP requirements, lifecycle implications, and user experience considerations.",
    "answer": "PiP allows app to display in small window while user interacts with other apps. Configure aspect ratio, handle lifecycle, provide custom actions. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "PiP allows app to display in small window while user interacts with other apps. Configure aspect ratio, handle lifecycle, provide custom actions."
  },
  {
    "id": 221,
    "level": "senior",
    "question": "What is Compose's ModalBottomSheet vs ModalDrawer?",
    "look_for": "Understanding of use cases, implementation patterns, and Material Design guidelines.",
    "answer": "ModalBottomSheet slides from bottom with scrim. ModalDrawer slides from side. Both block interaction with content behind. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "ModalBottomSheet slides from bottom with scrim. ModalDrawer slides from side. Both block interaction with content behind."
  },
  {
    "id": 222,
    "level": "senior",
    "question": "How do you implement proper text handling and typography?",
    "look_for": "Understanding of typography scales, font resources, and text performance optimization.",
    "answer": "Use TextAppearance styles, support text scaling, handle long text, implement ellipsize, support RTL, use appropriate fonts, consider accessibility. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use TextAppearance styles, support text scaling, handle long text, implement ellipsize, support RTL, use appropriate fonts, consider accessibility."
  },
  {
    "id": 223,
    "level": "senior",
    "question": "Explain Android's SyncAdapter framework.",
    "look_for": "Understanding of migration path, account authenticator integration, and modern alternatives.",
    "answer": "SyncAdapter is legacy framework for data synchronization with server accounts. Now deprecated in favor of **WorkManager** with appropriate constraints. Since this approach is deprecated, modern Android development uses alternatives like Kotlin Coroutines, Flow, or WorkManager, which provide better lifecycle awareness, error handling, and performance. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "SyncAdapter is legacy framework for data synchronization with server accounts. Now deprecated in favor of WorkManager with appropriate constraints."
  },
  {
    "id": 224,
    "level": "senior",
    "question": "What is Kotlin's operator overloading?",
    "look_for": "Understanding of available operators, conventions, and appropriate use cases.",
    "answer": "Operator overloading allows defining behavior for operators (+, -, *, etc.) on custom types using operator functions. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Operator overloading allows defining behavior for operators (+, -, *, etc.) on custom types using operator functions."
  },
  {
    "id": 225,
    "level": "senior",
    "question": "How do you implement proper drag and drop?",
    "look_for": "Understanding of drag shadows, clip data, and cross-app drag and drop.",
    "answer": "**Use** View.startDragAndDrop for drag source, implement OnDragListener for drop target, handle DragEvent actions, provide visual feedback. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use View.startDragAndDrop for drag source, implement OnDragListener for drop target, handle DragEvent actions, provide visual feedback."
  },
  {
    "id": 226,
    "level": "senior",
    "question": "Explain Android's MediaStore API changes.",
    "look_for": "Understanding of scoped storage migration, content URI handling, and permission requirements.",
    "answer": "Scoped storage changes require MediaStore for media access, query collections, handle pending media, implement file operations properly. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Scoped storage changes require MediaStore for media access, query collections, handle pending media, implement file operations properly."
  },
  {
    "id": 227,
    "level": "senior",
    "question": "What is Compose's animateContentSize?",
    "look_for": "Understanding of animation configuration, interaction with other animations, and performance.",
    "answer": "animateContentSize modifier automatically animates size changes of composable content, useful for expanding/collapsing views. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "animateContentSize modifier automatically animates size changes of composable content, useful for expanding/collapsing views."
  },
  {
    "id": 228,
    "level": "senior",
    "question": "How do you implement proper print framework integration?",
    "look_for": "Understanding of print preview, page layout calculation, and print job configuration.",
    "answer": "**Use** PrintManager, create PrintDocumentAdapter, handle page layout, implement custom print jobs, support PDF generation. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use PrintManager, create PrintDocumentAdapter, handle page layout, implement custom print jobs, support PDF generation."
  },
  {
    "id": 229,
    "level": "senior",
    "question": "Explain Android's Wifi and connectivity management.",
    "look_for": "Understanding of metered networks, network capabilities, and Android 10+ restrictions.",
    "answer": "Use ConnectivityManager for network state, NetworkCallback for monitoring, WifiManager for wifi operations, handle network changes properly. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Use ConnectivityManager for network state, NetworkCallback for monitoring, WifiManager for wifi operations, handle network changes properly."
  },
  {
    "id": 230,
    "level": "senior",
    "question": "What is the difference between atomic and volatile in concurrent programming?",
    "look_for": "Understanding of memory visibility, happens-before relationship, and when to use each.",
    "answer": "Volatile ensures visibility across threads. Atomic classes (AtomicInteger) provide atomic read-modify-write operations with compare-and-swap. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Volatile ensures visibility across threads. Atomic classes (AtomicInteger) provide atomic read-modify-write operations with compare-and-swap."
  },
  {
    "id": 231,
    "level": "senior",
    "question": "How do you implement proper Bluetooth integration?",
    "look_for": "Understanding of BLE vs classic Bluetooth, permission changes across versions, and connection management.",
    "answer": "Use BluetoothAdapter for classic Bluetooth, BluetoothLeScanner for BLE, handle permissions, manage connections, implement GATT operations for BLE. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use BluetoothAdapter for classic Bluetooth, BluetoothLeScanner for BLE, handle permissions, manage connections, implement GATT operations for BLE."
  },
  {
    "id": 232,
    "level": "senior",
    "question": "Explain Android's Storage Access Framework.",
    "look_for": "Understanding of document tree access, persistent permissions, and content URI handling.",
    "answer": "SAF provides unified way to access documents from various providers, use ACTION_OPEN_DOCUMENT and ACTION_CREATE_DOCUMENT intents. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "SAF provides unified way to access documents from various providers, use ACTION_OPEN_DOCUMENT and ACTION_CREATE_DOCUMENT intents."
  },
  {
    "id": 233,
    "level": "senior",
    "question": "What is Compose's InfiniteTransition?",
    "look_for": "Understanding of infinite animations, multiple animated values, and lifecycle considerations.",
    "answer": "InfiniteTransition runs animations indefinitely without stopping, useful for loading indicators or continuous animations. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "InfiniteTransition runs animations indefinitely without stopping, useful for loading indicators or continuous animations."
  },
  {
    "id": 234,
    "level": "senior",
    "question": "How do you implement proper sensor integration?",
    "look_for": "Understanding of sensor types, coordinate systems, power consumption, and data filtering.",
    "answer": "Use SensorManager, register listeners with appropriate sampling rates, unregister in lifecycle callbacks, batch sensor events, handle sensor availability. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Use SensorManager, register listeners with appropriate sampling rates, unregister in lifecycle callbacks, batch sensor events, handle sensor availability."
  },
  {
    "id": 235,
    "level": "senior",
    "question": "Explain Android's Text-to-Speech engine.",
    "look_for": "Understanding of language support, speech synthesis, and error handling.",
    "answer": "Use TextToSpeech class, initialize asynchronously, set language, configure speech parameters, handle utterance callbacks, release resources. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Use TextToSpeech class, initialize asynchronously, set language, configure speech parameters, handle utterance callbacks, release resources."
  },
  {
    "id": 236,
    "level": "senior",
    "question": "What is Kotlin's type aliases?",
    "look_for": "Understanding that they don't create new types, just aliases, and appropriate use cases.",
    "answer": "Type aliases create alternative names for existing types, improving code readability for complex generic types or function types. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Type aliases create alternative names for existing types, improving code readability for complex generic types or function types."
  },
  {
    "id": 237,
    "level": "senior",
    "question": "How do you implement proper NFC integration?",
    "look_for": "Understanding of NFC modes (reader, P2P, card emulation), NDEF format, and Android Beam deprecation.",
    "answer": "Use NfcAdapter, implement foreground dispatch or intent filters, handle NDEF messages, implement peer-to-peer communication or tag reading/writing. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use NfcAdapter, implement foreground dispatch or intent filters, handle NDEF messages, implement peer-to-peer communication or tag reading/writing."
  },
  {
    "id": 238,
    "level": "senior",
    "question": "Explain Android's AppSearch library.",
    "look_for": "Understanding of schema definition, search implementation, and comparison with Room FTS.",
    "answer": "AppSearch provides on-device full-text search, supports indexing app data, complex queries, ranking, and sharing data across apps. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "AppSearch provides on-device full-text search, supports indexing app data, complex queries, ranking, and sharing data across apps."
  },
  {
    "id": 239,
    "level": "senior",
    "question": "What is Compose's Crossfade?",
    "look_for": "Understanding of content keys, animation duration, and comparison with AnimatedContent.",
    "answer": "Crossfade animates switching between different content with fade animation, useful for simple content transitions. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Crossfade animates switching between different content with fade animation, useful for simple content transitions."
  },
  {
    "id": 240,
    "level": "senior",
    "question": "How do you implement proper geofencing?",
    "look_for": "Understanding of geofence lifecycle, battery considerations, and accuracy limitations.",
    "answer": "Use Geofencing API, define GeofenceRequest with transition types, implement GeofencingClient, handle intents in **BroadcastReceiver** or Service. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use Geofencing API, define GeofenceRequest with transition types, implement GeofencingClient, handle intents in BroadcastReceiver or Service."
  },
  {
    "id": 241,
    "level": "senior",
    "question": "Explain Android's ML Kit and on-device machine learning.",
    "look_for": "Understanding of bundled vs unbundled models, model deployment, and inference optimization.",
    "answer": "ML Kit provides ready-to-use ML APIs (text recognition, face detection, etc.), supports custom TensorFlow Lite models, runs on-device. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "ML Kit provides ready-to-use ML APIs (text recognition, face detection, etc.), supports custom TensorFlow Lite models, runs on-device."
  },
  {
    "id": 242,
    "level": "senior",
    "question": "What is the difference between SharedFlow and BroadcastChannel?",
    "look_for": "Understanding of migration path and SharedFlow advantages.",
    "answer": "BroadcastChannel is deprecated. **SharedFlow** is its replacement, offering more configuration, better integration with **Flow** API. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "BroadcastChannel is deprecated. SharedFlow is its replacement, offering more configuration, better integration with Flow API."
  },
  {
    "id": 243,
    "level": "senior",
    "question": "How do you implement proper barcode scanning?",
    "look_for": "Understanding of supported formats, real-time processing, and error handling.",
    "answer": "**Use** ML Kit Barcode Scanning, CameraX for camera feed, process frames, handle different barcode formats, provide visual feedback. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use ML Kit Barcode Scanning, CameraX for camera feed, process frames, handle different barcode formats, provide visual feedback."
  },
  {
    "id": 244,
    "level": "senior",
    "question": "Explain Android's Health Connect API.",
    "look_for": "Understanding of data types, permissions, and integration with health apps.",
    "answer": "Health Connect provides centralized health and fitness data platform, allows apps to read/write health data with user permission. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Health Connect provides centralized health and fitness data platform, allows apps to read/write health data with user permission."
  },
  {
    "id": 245,
    "level": "senior",
    "question": "What is Compose's Scaffold component?",
    "look_for": "Understanding of slot API, coordinate app bar with content, and state management.",
    "answer": "Scaffold provides Material Design layout structure with slots for TopAppBar, BottomBar, FAB, Drawer, and SnackbarHost. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Scaffold provides Material Design layout structure with slots for TopAppBar, BottomBar, FAB, Drawer, and SnackbarHost."
  },
  {
    "id": 246,
    "level": "senior",
    "question": "How do you implement proper speech recognition?",
    "look_for": "Understanding of continuous recognition, offline vs online recognition, and result confidence.",
    "answer": "**Use** SpeechRecognizer API, request RECORD_AUDIO permission, handle recognition results, implement error handling, provide UI feedback. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use SpeechRecognizer API, request RECORD_AUDIO permission, handle recognition results, implement error handling, provide UI feedback."
  },
  {
    "id": 247,
    "level": "senior",
    "question": "Explain Android's Privacy Sandbox.",
    "look_for": "Understanding of privacy implications, API integration, and migration from advertising ID.",
    "answer": "Privacy Sandbox provides privacy-preserving APIs for ads (Topics API, FLEDGE, Attribution Reporting) replacing tracking identifiers. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Privacy Sandbox provides privacy-preserving APIs for ads (Topics API, FLEDGE, Attribution Reporting) replacing tracking identifiers."
  },
  {
    "id": 248,
    "level": "senior",
    "question": "What is Kotlin's tailrec modifier?",
    "look_for": "Understanding of tail call optimization, requirements for tail recursion, and use cases.",
    "answer": "tailrec optimizes tail-recursive functions into loops, preventing stack overflow for deep recursion. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "tailrec optimizes tail-recursive functions into loops, preventing stack overflow for deep recursion."
  },
  {
    "id": 249,
    "level": "senior",
    "question": "How do you implement proper VPN integration?",
    "look_for": "Understanding of VPN architecture, packet handling, and Android VPN requirements.",
    "answer": "**UseVpnService,** establish VPN connection, handle routing, implement packet forwarding, maintain connection state. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "UseVpnService, establish VPN connection, handle routing, implement packet forwarding, maintain connection state."
  },
  {
    "id": 250,
    "level": "senior",
    "question": "Explain Android's Custom Tabs.",
    "look_for": "Understanding of CustomTabsIntent, session management, and fallback to browser.",
    "answer": "Custom Tabs provide lightweight browser experience within app, pre-warming, custom UI colors, share menu, faster than WebView. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Custom Tabs provide lightweight browser experience within app, pre-warming, custom UI colors, share menu, faster than WebView."
  },
  {
    "id": 251,
    "level": "senior",
    "question": "What is Compose's LazyColumn vs Column with Modifier.verticalScroll?",
    "look_for": "Understanding of composition performance, when to use each, and memory implications.",
    "answer": "LazyColumn composes items lazily (only visible items), efficient for large lists. Column composes all items, suitable for small fixed content. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "LazyColumn composes items lazily (only visible items), efficient for large lists. Column composes all items, suitable for small fixed content."
  },
  {
    "id": 252,
    "level": "senior",
    "question": "How do you implement proper app widgets?",
    "look_for": "Understanding of RemoteViews limitations, update strategies, and Android 12+ improvements.",
    "answer": "**Create** AppWidgetProvider, define widget layout, configure update frequency, handle click events via PendingIntents, support different sizes. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Create AppWidgetProvider, define widget layout, configure update frequency, handle click events via PendingIntents, support different sizes."
  },
  {
    "id": 253,
    "level": "senior",
    "question": "Explain Android's Nearby Connections API.",
    "look_for": "Understanding of connection strategies, data transfer patterns, and offline communication.",
    "answer": "Nearby Connections provides P2P communication without internet, supports WiFi Direct, Bluetooth, discovery, and connection management. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Nearby Connections provides P2P communication without internet, supports WiFi Direct, Bluetooth, discovery, and connection management."
  },
  {
    "id": 254,
    "level": "senior",
    "question": "What is the difference between MediatorLiveData and Transformations.switchMap?",
    "look_for": "Understanding of use cases, multiple source handling, and migration to Flow.",
    "answer": "MediatorLiveData observes multiple **LiveData** sources. switchMap transforms one **LiveData** to another, canceling previous observation. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "MediatorLiveData observes multiple LiveData sources. switchMap transforms one LiveData to another, canceling previous observation."
  },
  {
    "id": 255,
    "level": "senior",
    "question": "How do you implement proper contacts integration?",
    "look_for": "Understanding of contact data structure, RawContacts vs Contacts, and efficient querying.",
    "answer": "**Use** ContactsContract, request READ_CONTACTS permission, query contacts properly, handle aggregated contacts, display contact picker. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use ContactsContract, request READ_CONTACTS permission, query contacts properly, handle aggregated contacts, display contact picker."
  },
  {
    "id": 256,
    "level": "senior",
    "question": "Explain Android's Chrome Custom Tabs vs Trusted Web Activity.",
    "look_for": "Understanding of PWA integration, verification process, and use cases.",
    "answer": "Custom Tabs show browser chrome. TWA displays web app in fullscreen without browser UI, requires Digital Asset Links verification. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Custom Tabs show browser chrome. TWA displays web app in fullscreen without browser UI, requires Digital Asset Links verification."
  },
  {
    "id": 257,
    "level": "senior",
    "question": "What is Compose's BoxWithConstraints?",
    "look_for": "Understanding of constraints access, responsive design patterns, and performance considerations.",
    "answer": "BoxWithConstraints provides constraints (maxWidth, maxHeight) to child composables, enabling responsive layouts based on available space. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "BoxWithConstraints provides constraints (maxWidth, maxHeight) to child composables, enabling responsive layouts based on available space."
  },
  {
    "id": 258,
    "level": "senior",
    "question": "How do you implement proper location services with FusedLocationProvider?",
    "look_for": "Understanding of location accuracy, battery optimization, and background location restrictions.",
    "answer": "Use FusedLocationProviderClient, request location permissions, configure location request parameters, handle location updates, implement geofencing. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use FusedLocationProviderClient, request location permissions, configure location request parameters, handle location updates, implement geofencing."
  },
  {
    "id": 259,
    "level": "senior",
    "question": "Explain Android's accompanist libraries.",
    "look_for": "Understanding of available libraries, migration to official Compose equivalents, and deprecation status.",
    "answer": "Accompanist provides supplementary **Compose** libraries (permissions, system UI controller, pager, navigation animation) filling gaps in Jetpack **Compose**. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Accompanist provides supplementary Compose libraries (permissions, system UI controller, pager, navigation animation) filling gaps in Jetpack Compose."
  },
  {
    "id": 260,
    "level": "senior",
    "question": "What is Kotlin's expect/actual mechanism?",
    "look_for": "Understanding of multiplatform architecture, use cases, and limitations.",
    "answer": "expect/actual allows declaring platform-agnostic API (expect) with platform-specific implementations (actual) for multiplatform projects. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "expect/actual allows declaring platform-agnostic API (expect) with platform-specific implementations (actual) for multiplatform projects."
  },
  {
    "id": 261,
    "level": "senior",
    "question": "How do you implement proper calendar and event integration?",
    "look_for": "Understanding of calendar provider structure, attendees handling, and reminders.",
    "answer": "**Use** CalendarContract, request CALENDAR permissions, query calendars and events, insert/update events, handle recurrence rules. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use CalendarContract, request CALENDAR permissions, query calendars and events, insert/update events, handle recurrence rules."
  },
  {
    "id": 262,
    "level": "senior",
    "question": "Explain Android's Performance monitoring tools.",
    "look_for": "Understanding of profiling workflow, bottleneck identification, and metrics interpretation.",
    "answer": "Use Android Profiler (CPU, memory, network), Systrace/Perfetto, StrictMode, Macrobenchmark for UI, Firebase Performance Monitoring. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Use Android Profiler (CPU, memory, network), Systrace/Perfetto, StrictMode, Macrobenchmark for UI, Firebase Performance Monitoring."
  },
  {
    "id": 263,
    "level": "senior",
    "question": "What is Compose's SideEffect composable?",
    "look_for": "Understanding of execution timing, use cases, and comparison with LaunchedEffect.",
    "answer": "SideEffect runs after every successful recomposition, useful for publishing **Compose** state to non-**Compose** code. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "SideEffect runs after every successful recomposition, useful for publishing Compose state to non-Compose code."
  },
  {
    "id": 264,
    "level": "senior",
    "question": "How do you implement proper in-app purchases?",
    "look_for": "Understanding of product types, server-side verification, and subscription management.",
    "answer": "**Use** Google Play Billing Library, query products, initiate purchase flow, verify purchases, consume/acknowledge, handle subscriptions. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use Google Play Billing Library, query products, initiate purchase flow, verify purchases, consume/acknowledge, handle subscriptions."
  },
  {
    "id": 265,
    "level": "senior",
    "question": "Explain Android's App Links verification.",
    "look_for": "Understanding of assetlinks.json file, intent filter configuration, and testing verification.",
    "answer": "Digital Asset Links verification proves domain ownership, enabling direct app opening from verified URLs without disambiguation dialog. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Digital Asset Links verification proves domain ownership, enabling direct app opening from verified URLs without disambiguation dialog."
  },
  {
    "id": 266,
    "level": "senior",
    "question": "What is the difference between produce and flow builder?",
    "look_for": "Understanding of hot vs cold streams, appropriate use cases, and performance implications.",
    "answer": "produce creates **Channel** (hot), flow builder creates cold **Flow**. Channel sends to multiple receivers, Flow is unicast. Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "produce creates Channel (hot), flow builder creates cold Flow. Channel sends to multiple receivers, Flow is unicast."
  },
  {
    "id": 267,
    "level": "senior",
    "question": "How do you implement proper SMS and phone integration?",
    "look_for": "Understanding of SMS permissions changes, user verification best practices, and alternative approaches.",
    "answer": "**Use** SMS Retriever API for one-tap verification, TelephonyManager for phone state, ACTION_DIAL for dialing, handle runtime permissions. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use SMS Retriever API for one-tap verification, TelephonyManager for phone state, ACTION_DIAL for dialing, handle runtime permissions."
  },
  {
    "id": 268,
    "level": "senior",
    "question": "Explain Android's MediaProjection API.",
    "look_for": "Understanding of screen capture setup, privacy implications, and recording implementation.",
    "answer": "MediaProjection captures screen content for recording or casting, requires user consent via MediaProjectionManager, handles VirtualDisplay. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "MediaProjection captures screen content for recording or casting, requires user consent via MediaProjectionManager, handles VirtualDisplay."
  },
  {
    "id": 269,
    "level": "senior",
    "question": "What is Compose's DisposableEffect use cases?",
    "look_for": "Understanding of resource cleanup, lifecycle observation, and proper key usage.",
    "answer": "DisposableEffect registers observers/listeners that need cleanup, calls onDispose when effect leaves composition or key changes. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "DisposableEffect registers observers/listeners that need cleanup, calls onDispose when effect leaves composition or key changes."
  },
  {
    "id": 270,
    "level": "senior",
    "question": "How do you implement proper file encryption?",
    "look_for": "Understanding of encryption algorithms, key management, and AndroidKeyStore security.",
    "answer": "Use Android Keystore for key management, EncryptedFile/EncryptedSharedPreferences from Security Crypto library, or implement custom AES encryption. Proper implementation requires understanding the underlying mechanisms and following Android best practices. Security is paramount in mobile development - always follow the principle of least privilege, validate inputs, encrypt sensitive data, and keep security libraries updated to protect user privacy and data.",
    "short_answer": "Use Android Keystore for key management, EncryptedFile/EncryptedSharedPreferences from Security Crypto library, or implement custom AES encryption."
  },
  {
    "id": 271,
    "level": "senior",
    "question": "Explain Android's Device-to-Device communication patterns.",
    "look_for": "Understanding of trade-offs (range, setup, bandwidth), appropriate protocol selection.",
    "answer": "Options include Bluetooth, WiFi Direct, Nearby Connections, NFC, and Firebase Cloud Messaging for server-mediated communication. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Options include Bluetooth, WiFi Direct, Nearby Connections, NFC, and Firebase Cloud Messaging for server-mediated communication."
  },
  {
    "id": 272,
    "level": "senior",
    "question": "What is Kotlin's @BuilderInference?",
    "look_for": "Understanding of type inference scope, DSL design, and appropriate usage.",
    "answer": "@BuilderInference enables type inference for generic builders, improving DSL ergonomics by inferring types from builder lambda. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "@BuilderInference enables type inference for generic builders, improving DSL ergonomics by inferring types from builder lambda."
  },
  {
    "id": 273,
    "level": "senior",
    "question": "How do you implement proper push notification handling?",
    "look_for": "Understanding of message types, background processing limitations, and notification best practices.",
    "answer": "Use Firebase Cloud Messaging, handle data/notification messages, implement notification channels, handle background restrictions, track delivery. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use Firebase Cloud Messaging, handle data/notification messages, implement notification channels, handle background restrictions, track delivery."
  },
  {
    "id": 274,
    "level": "senior",
    "question": "Explain Android's ViewModel SavedStateHandle.",
    "look_for": "Understanding of state restoration, process death handling, and integration patterns.",
    "answer": "SavedStateHandle survives process death, stores key-value data, provides **LiveData**/**StateFlow** access, integrates with Navigation arguments. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "SavedStateHandle survives process death, stores key-value data, provides LiveData/StateFlow access, integrates with Navigation arguments."
  },
  {
    "id": 275,
    "level": "senior",
    "question": "What is Compose's remember with calculation?",
    "look_for": "Understanding of key-based recomputation, comparison with derivedStateOf, and performance implications.",
    "answer": "remember with calculation key recomputes value when key changes, useful for derived state based on other state. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "remember with calculation key recomputes value when key changes, useful for derived state based on other state."
  },
  {
    "id": 276,
    "level": "senior",
    "question": "How do you implement proper CI/CD for Android?",
    "look_for": "Understanding of pipeline setup, artifact management, and deployment automation.",
    "answer": "**Use** GitHub Actions/Jenkins/CircleCI, automate builds, run tests, lint checks, deploy to Play Store, manage signing keys securely. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use GitHub Actions/Jenkins/CircleCI, automate builds, run tests, lint checks, deploy to Play Store, manage signing keys securely."
  },
  {
    "id": 277,
    "level": "senior",
    "question": "Explain Android's WakeLock and battery optimization.",
    "look_for": "Understanding of battery impact, permission requirements, and alternatives.",
    "answer": "WakeLock keeps device awake for critical operations, must be released promptly. Use Doze exemption carefully, prefer **WorkManager** for deferred work. Optimizing this aspect directly impacts app performance, battery life, and user experience. Use profiling tools like Android Profiler to measure improvements and identify bottlenecks. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "WakeLock keeps device awake for critical operations, must be released promptly. Use Doze exemption carefully, prefer WorkManager for deferred work."
  },
  {
    "id": 278,
    "level": "senior",
    "question": "What is the difference between viewModelScope and lifecycleScope?",
    "look_for": "Understanding of scope lifecycle, appropriate usage, and cancellation behavior.",
    "answer": "viewModelScope tied to ViewModel lifecycle, cancelled when ViewModel cleared. lifecycleScope tied to lifecycle owner (**Activity**/Fragment), cancelled when destroyed. Understanding this lifecycle is crucial for proper resource management, state preservation, and preventing memory leaks in Android applications. **When to use**: Choose based on your specific requirements - consider performance needs, API compatibility, code maintainability, and whether you need the specific features each approach offers.",
    "short_answer": "viewModelScope tied to ViewModel lifecycle, cancelled when ViewModel cleared. lifecycleScope tied to lifecycle owner (Activity/Fragment), cancelled when destroyed."
  },
  {
    "id": 279,
    "level": "senior",
    "question": "How do you implement proper audio recording and playback?",
    "look_for": "Understanding of audio formats, buffer management, and audio focus handling.",
    "answer": "Use AudioRecord for recording, AudioTrack for playback, request RECORD_AUDIO permission, handle audio focus, support different sample rates/formats. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use AudioRecord for recording, AudioTrack for playback, request RECORD_AUDIO permission, handle audio focus, support different sample rates/formats."
  },
  {
    "id": 280,
    "level": "senior",
    "question": "Explain Android's Firebase Remote Config strategies.",
    "look_for": "Understanding of config strategies, cache management, and real-time updates.",
    "answer": "Remote Config enables A/B testing, gradual rollouts, server-side feature flags. Use conditions, personalization, and proper defaults. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Remote Config enables A/B testing, gradual rollouts, server-side feature flags. Use conditions, personalization, and proper defaults."
  },
  {
    "id": 281,
    "level": "senior",
    "question": "What is Compose's Layout composable?",
    "look_for": "Understanding of measurement policy, custom layout implementation, and intrinsic measurements.",
    "answer": "Layout is the fundamental composable for custom layouts, provides measure and placement control for children. This is a fundamental concept in Android development that developers should understand for building robust applications. Following Material Design guidelines and Android UX best practices ensures your app feels native, intuitive, and accessible to all users across different devices and screen sizes.",
    "short_answer": "Layout is the fundamental composable for custom layouts, provides measure and placement control for children."
  },
  {
    "id": 282,
    "level": "senior",
    "question": "How do you implement proper video recording?",
    "look_for": "Understanding of encoding formats, quality vs size trade-offs, and camera lifecycle.",
    "answer": "**Use** CameraX VideoCapture, MediaRecorder, or MediaCodec for advanced control. Handle permissions, storage, quality settings, and orientation. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use CameraX VideoCapture, MediaRecorder, or MediaCodec for advanced control. Handle permissions, storage, quality settings, and orientation."
  },
  {
    "id": 283,
    "level": "senior",
    "question": "Explain Android's Play Feature Delivery.",
    "look_for": "Understanding of delivery modes, SplitInstallManager, and feature module configuration.",
    "answer": "Play Feature Delivery splits app into modules delivered on-demand, conditional, or at install, reducing initial download size. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Play Feature Delivery splits app into modules delivered on-demand, conditional, or at install, reducing initial download size."
  },
  {
    "id": 284,
    "level": "senior",
    "question": "What is Kotlin's suspend function transformation?",
    "look_for": "Understanding of CPS transformation, Continuation interface, and performance characteristics.",
    "answer": "Compiler transforms **suspend** functions into state machines with Continuation parameter, enabling suspension and resumption without blocking threads. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Compiler transforms suspend functions into state machines with Continuation parameter, enabling suspension and resumption without blocking threads."
  },
  {
    "id": 285,
    "level": "senior",
    "question": "How do you implement proper QR code generation?",
    "look_for": "Understanding of QR code formats, error correction, and display optimization.",
    "answer": "**Use** ZXing library, encode data to QR format, render to Bitmap, handle different error correction levels and sizes. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use ZXing library, encode data to QR format, render to Bitmap, handle different error correction levels and sizes."
  },
  {
    "id": 286,
    "level": "senior",
    "question": "Explain Android's Photo Picker API.",
    "look_for": "Understanding of permission benefits, multi-select support, and fallback strategies.",
    "answer": "Photo Picker (Android 11+) provides privacy-preserving media selection without requiring storage permissions, consistent UI across devices. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Photo Picker (Android 11+) provides privacy-preserving media selection without requiring storage permissions, consistent UI across devices."
  },
  {
    "id": 287,
    "level": "senior",
    "question": "What is Compose's Modifier.drawWithCache?",
    "look_for": "Understanding of drawing optimization, cache invalidation, and comparison with drawBehind.",
    "answer": "drawWithCache caches drawing operations, rebuilding cache only when size or dependencies change, optimizing custom drawing performance. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "drawWithCache caches drawing operations, rebuilding cache only when size or dependencies change, optimizing custom drawing performance."
  },
  {
    "id": 288,
    "level": "senior",
    "question": "How do you implement proper rate limiting?",
    "look_for": "Understanding of rate limiting algorithms, backoff strategies, and user experience considerations.",
    "answer": "Implement token bucket or leaky bucket algorithm, track request timestamps, use RxJava throttle/debounce or **Flow** operators, handle API rate limits. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Implement token bucket or leaky bucket algorithm, track request timestamps, use RxJava throttle/debounce or Flow operators, handle API rate limits."
  },
  {
    "id": 289,
    "level": "senior",
    "question": "Explain Android's Permissions best practices.",
    "look_for": "Understanding of permission UX, shouldShowRequestPermissionRationale, and granular permissions.",
    "answer": "Request permissions in context, explain rationale, handle denial gracefully, use least privilege, request runtime permissions at appropriate time. Security is paramount in mobile development - always follow the principle of least privilege, validate inputs, encrypt sensitive data, and keep security libraries updated to protect user privacy and data. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "Request permissions in context, explain rationale, handle denial gracefully, use least privilege, request runtime permissions at appropriate time."
  },
  {
    "id": 290,
    "level": "senior",
    "question": "What is the difference between Channel and SharedFlow buffer strategies?",
    "look_for": "Understanding of backpressure handling, appropriate buffer configuration, and use cases.",
    "answer": "**Channel** buffers with capacity, overflow strategies (**suspend**, drop). SharedFlow has replay and buffer with overflow strategies (suspend, drop oldest/latest). Choosing the right approach depends on your specific use case, performance requirements, and code maintainability needs. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Channel buffers with capacity, overflow strategies (suspend, drop). SharedFlow has replay and buffer with overflow strategies (suspend, drop oldest/latest)."
  },
  {
    "id": 291,
    "level": "senior",
    "question": "How do you implement proper video streaming?",
    "look_for": "Understanding of streaming protocols, buffer management, and quality adaptation.",
    "answer": "**Use** ExoPlayer with adaptive streaming (DASH, HLS), implement caching, handle DRM, provide playback controls, optimize buffering strategy. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use ExoPlayer with adaptive streaming (DASH, HLS), implement caching, handle DRM, provide playback controls, optimize buffering strategy."
  },
  {
    "id": 292,
    "level": "senior",
    "question": "Explain Android's App Compatibility and AndroidX migration.",
    "look_for": "Understanding of migration process, Jetifier for dependencies, and version management.",
    "answer": "AndroidX replaces Support Library with consistent packaging, independent versioning. Migrate using Android Studio refactoring tools. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "AndroidX replaces Support Library with consistent packaging, independent versioning. Migrate using Android Studio refactoring tools."
  },
  {
    "id": 293,
    "level": "senior",
    "question": "What is Compose's GraphicsLayer modifier?",
    "look_for": "Understanding of layer caching benefits, transformation compositing, and performance impact.",
    "answer": "GraphicsLayer enables hardware-accelerated transformations (rotation, scale, alpha) with optional caching, improving animation performance. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions.",
    "short_answer": "GraphicsLayer enables hardware-accelerated transformations (rotation, scale, alpha) with optional caching, improving animation performance."
  },
  {
    "id": 294,
    "level": "senior",
    "question": "How do you implement proper OAuth2 authentication?",
    "look_for": "Understanding of OAuth2 flows, token security, and secure storage practices.",
    "answer": "**Use** AppAuth library, implement authorization code flow with PKCE, store tokens securely, handle token refresh, implement logout. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use AppAuth library, implement authorization code flow with PKCE, store tokens securely, handle token refresh, implement logout."
  },
  {
    "id": 295,
    "level": "senior",
    "question": "Explain Android's Google Play services and Play Core library.",
    "look_for": "Understanding of dependency management, availability checking, and feature implementations.",
    "answer": "Google Play services provides APIs for Google services. Play Core library handles app updates, feature modules, in-app reviews. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Google Play services provides APIs for Google services. Play Core library handles app updates, feature modules, in-app reviews."
  },
  {
    "id": 296,
    "level": "senior",
    "question": "What is Kotlin's builder type inference?",
    "look_for": "Understanding of DSL design, type inference scope, and limitations.",
    "answer": "**Builder** type inference infers generic types from builder lambda body, avoiding explicit type parameters in DSL-style builders. This is a fundamental concept in Android development that developers should understand for building robust applications. This is a modern Kotlin feature that provides more concise, safer, and more expressive code compared to traditional Java approaches, making Android development more efficient and enjoyable.",
    "short_answer": "Builder type inference infers generic types from builder lambda body, avoiding explicit type parameters in DSL-style builders."
  },
  {
    "id": 297,
    "level": "senior",
    "question": "How do you implement proper image cropping?",
    "look_for": "Understanding of bitmap manipulation, memory management, and output quality.",
    "answer": "**Use** uCrop library or implement custom crop view, handle aspect ratios, provide zoom/pan, save cropped result efficiently. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use uCrop library or implement custom crop view, handle aspect ratios, provide zoom/pan, save cropped result efficiently."
  },
  {
    "id": 298,
    "level": "senior",
    "question": "Explain Android's Privacy Dashboard and indicators.",
    "look_for": "Understanding of privacy requirements, attribution tags, and user transparency.",
    "answer": "Privacy Dashboard (Android 12+) shows permission usage. Privacy indicators show camera/microphone access. Apps must handle transparency. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "Privacy Dashboard (Android 12+) shows permission usage. Privacy indicators show camera/microphone access. Apps must handle transparency."
  },
  {
    "id": 299,
    "level": "senior",
    "question": "What is Compose's PointerInput modifier?",
    "look_for": "Understanding of gesture detection, touch event handling, and existing gesture detectors.",
    "answer": "PointerInput detects gestures and touch events, provides low-level touch handling, supports custom gestures. This is a fundamental concept in Android development that developers should understand for building robust applications. As a senior developer, understanding the trade-offs, edge cases, and production implications of this concept is essential for making informed architectural decisions. **Best practice**: Test thoroughly, handle edge cases, consider backward compatibility, and document your implementation for team members.",
    "short_answer": "PointerInput detects gestures and touch events, provides low-level touch handling, supports custom gestures."
  },
  {
    "id": 300,
    "level": "senior",
    "question": "How do you implement proper app signing and key management?",
    "look_for": "Understanding of signing configurations, Play App Signing benefits, and security best practices.",
    "answer": "**Use** Android Keystore for signing keys, implement Play App Signing, protect keystore files, set up key rotation, maintain backup keys. Proper implementation requires understanding the underlying mechanisms and following Android best practices.",
    "short_answer": "Use Android Keystore for signing keys, implement Play App Signing, protect keystore files, set up key rotation, maintain backup keys."
  }
]